-- ============================================
-- 🍷 LES CAVES D'ALBERT - REQUÊTES ANALYTIQUES
-- ============================================
-- Collection de requêtes prêtes à l'emploi pour l'analyse business

USE DATABASE CAVES_ALBERT_DB;
USE SCHEMA PRODUCTION;

-- ============================================
-- 📊 SECTION 1: KPI TEMPS RÉEL
-- ============================================

-- 1.1 - Dashboard du jour (métriques clés)
SELECT
    '📅 Aujourd''hui' AS PERIOD,
    COUNT(DISTINCT ORDER_ID) AS TOTAL_ORDERS,
    COUNT(DISTINCT CUSTOMER_ID) AS UNIQUE_CUSTOMERS,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE,
    SUM(QUANTITY) AS TOTAL_UNITS_SOLD
FROM ORDERS
WHERE ORDER_DATE = CURRENT_DATE();

-- 1.2 - Comparaison aujourd'hui vs hier
WITH today AS (
    SELECT
        COUNT(*) AS orders,
        SUM(TOTAL_AMOUNT) AS revenue
    FROM ORDERS
    WHERE ORDER_DATE = CURRENT_DATE()
),
yesterday AS (
    SELECT
        COUNT(*) AS orders,
        SUM(TOTAL_AMOUNT) AS revenue
    FROM ORDERS
    WHERE ORDER_DATE = DATEADD('day', -1, CURRENT_DATE())
)
SELECT
    t.orders AS orders_today,
    y.orders AS orders_yesterday,
    ROUND(((t.orders - y.orders) / y.orders) * 100, 2) AS orders_growth_pct,
    t.revenue AS revenue_today,
    y.revenue AS revenue_yesterday,
    ROUND(((t.revenue - y.revenue) / y.revenue) * 100, 2) AS revenue_growth_pct
FROM today t, yesterday y;

-- 1.3 - État de l'inventaire (snapshot actuel)
SELECT
    PRODUCT_CATEGORY,
    COUNT(DISTINCT PRODUCT_ID) AS PRODUCT_COUNT,
    SUM(CURRENT_STOCK_LEVEL) AS TOTAL_STOCK,
    AVG(CURRENT_STOCK_LEVEL) AS AVG_STOCK_PER_PRODUCT,
    MIN(CURRENT_STOCK_LEVEL) AS MIN_STOCK,
    MAX(CURRENT_STOCK_LEVEL) AS MAX_STOCK
FROM INVENTORY_CURRENT
GROUP BY PRODUCT_CATEGORY
ORDER BY TOTAL_STOCK DESC;

-- ============================================
-- 🏆 SECTION 2: TOP PERFORMERS
-- ============================================

-- 2.1 - Top 10 produits par revenus (dernier mois)
SELECT
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(QUANTITY) AS UNITS_SOLD,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE,
    AVG(UNIT_PRICE) AS AVG_PRICE
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY PRODUCT_NAME, PRODUCT_CATEGORY
ORDER BY TOTAL_REVENUE DESC
LIMIT 10;

-- 2.2 - Top 10 produits par volume (quantité vendue)
SELECT
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    SUM(QUANTITY) AS TOTAL_UNITS_SOLD,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY PRODUCT_NAME, PRODUCT_CATEGORY
ORDER BY TOTAL_UNITS_SOLD DESC
LIMIT 10;

-- 2.3 - Top catégories de produits
SELECT
    PRODUCT_CATEGORY,
    COUNT(DISTINCT PRODUCT_ID) AS UNIQUE_PRODUCTS,
    COUNT(DISTINCT ORDER_ID) AS TOTAL_ORDERS,
    SUM(QUANTITY) AS TOTAL_UNITS,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE,
    AVG(UNIT_PRICE) AS AVG_UNIT_PRICE,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY PRODUCT_CATEGORY
ORDER BY TOTAL_REVENUE DESC;

-- 2.4 - Top 20 clients (par valeur)
SELECT
    CUSTOMER_ID,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(TOTAL_AMOUNT) AS LIFETIME_VALUE,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE,
    MIN(ORDER_DATE) AS FIRST_ORDER,
    MAX(ORDER_DATE) AS LAST_ORDER,
    DATEDIFF('day', MIN(ORDER_DATE), MAX(ORDER_DATE)) AS CUSTOMER_TENURE_DAYS,
    DATEDIFF('day', MAX(ORDER_DATE), CURRENT_DATE()) AS DAYS_SINCE_LAST_ORDER
FROM ORDERS
GROUP BY CUSTOMER_ID
ORDER BY LIFETIME_VALUE DESC
LIMIT 20;

-- ============================================
-- 📈 SECTION 3: TENDANCES ET ÉVOLUTION
-- ============================================

-- 3.1 - Évolution des ventes par jour (30 derniers jours)
SELECT
    ORDER_DATE,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    COUNT(DISTINCT CUSTOMER_ID) AS CUSTOMER_COUNT,
    SUM(TOTAL_AMOUNT) AS DAILY_REVENUE,
    SUM(QUANTITY) AS UNITS_SOLD,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY ORDER_DATE
ORDER BY ORDER_DATE DESC;

-- 3.2 - Tendance par catégorie (semaine par semaine)
SELECT
    DATE_TRUNC('week', ORDER_DATE) AS WEEK_START,
    PRODUCT_CATEGORY,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(TOTAL_AMOUNT) AS WEEKLY_REVENUE,
    SUM(QUANTITY) AS UNITS_SOLD
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -90, CURRENT_DATE())
GROUP BY DATE_TRUNC('week', ORDER_DATE), PRODUCT_CATEGORY
ORDER BY WEEK_START DESC, WEEKLY_REVENUE DESC;

-- 3.3 - Analyse de saisonnalité (jour de la semaine)
SELECT
    DAYNAME(ORDER_DATE) AS DAY_OF_WEEK,
    DAYOFWEEK(ORDER_DATE) AS DAY_NUMBER,
    COUNT(DISTINCT ORDER_ID) AS AVG_ORDERS,
    SUM(TOTAL_AMOUNT) AS AVG_REVENUE,
    SUM(QUANTITY) AS AVG_UNITS
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -90, CURRENT_DATE())
GROUP BY DAYNAME(ORDER_DATE), DAYOFWEEK(ORDER_DATE)
ORDER BY DAY_NUMBER;

-- 3.4 - Analyse horaire (heures de pointe)
SELECT
    HOUR(ORDER_TIMESTAMP) AS HOUR_OF_DAY,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(TOTAL_AMOUNT) AS REVENUE,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY HOUR(ORDER_TIMESTAMP)
ORDER BY HOUR_OF_DAY;

-- ============================================
-- 🔍 SECTION 4: ANALYSE DES CLIENTS
-- ============================================

-- 4.1 - Segmentation RFM (Recency, Frequency, Monetary)
WITH customer_metrics AS (
    SELECT
        CUSTOMER_ID,
        DATEDIFF('day', MAX(ORDER_DATE), CURRENT_DATE()) AS RECENCY_DAYS,
        COUNT(DISTINCT ORDER_ID) AS FREQUENCY,
        SUM(TOTAL_AMOUNT) AS MONETARY
    FROM ORDERS
    GROUP BY CUSTOMER_ID
),
rfm_scores AS (
    SELECT
        CUSTOMER_ID,
        RECENCY_DAYS,
        FREQUENCY,
        MONETARY,
        NTILE(5) OVER (ORDER BY RECENCY_DAYS DESC) AS R_SCORE,
        NTILE(5) OVER (ORDER BY FREQUENCY ASC) AS F_SCORE,
        NTILE(5) OVER (ORDER BY MONETARY ASC) AS M_SCORE
    FROM customer_metrics
)
SELECT
    CUSTOMER_ID,
    RECENCY_DAYS,
    FREQUENCY,
    ROUND(MONETARY, 2) AS LIFETIME_VALUE,
    R_SCORE,
    F_SCORE,
    M_SCORE,
    (R_SCORE + F_SCORE + M_SCORE) AS RFM_TOTAL,
    CASE
        WHEN R_SCORE >= 4 AND F_SCORE >= 4 AND M_SCORE >= 4 THEN '🌟 Champions'
        WHEN R_SCORE >= 3 AND F_SCORE >= 3 THEN '💎 Loyal Customers'
        WHEN R_SCORE >= 4 THEN '🔥 Recent Customers'
        WHEN F_SCORE >= 4 THEN '⭐ Frequent Buyers'
        WHEN M_SCORE >= 4 THEN '💰 High Spenders'
        WHEN R_SCORE <= 2 THEN '⚠️  At Risk'
        ELSE '📊 Regular'
    END AS CUSTOMER_SEGMENT
FROM rfm_scores
ORDER BY RFM_TOTAL DESC, MONETARY DESC;

-- 4.2 - Clients fidèles (5+ commandes, derniers 90 jours)
SELECT
    CUSTOMER_ID,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(TOTAL_AMOUNT) AS LIFETIME_VALUE,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE,
    MIN(ORDER_DATE) AS FIRST_ORDER,
    MAX(ORDER_DATE) AS LAST_ORDER,
    DATEDIFF('day', MIN(ORDER_DATE), MAX(ORDER_DATE)) AS TENURE_DAYS,
    ROUND(SUM(TOTAL_AMOUNT) / COUNT(DISTINCT ORDER_ID), 2) AS ORDER_VALUE,
    ROUND(COUNT(DISTINCT ORDER_ID) / 
          (DATEDIFF('day', MIN(ORDER_DATE), MAX(ORDER_DATE)) + 1) * 30, 2) AS ORDERS_PER_MONTH
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -90, CURRENT_DATE())
GROUP BY CUSTOMER_ID
HAVING ORDER_COUNT >= 5
ORDER BY LIFETIME_VALUE DESC;

-- 4.3 - Clients inactifs (pas de commande depuis 30+ jours)
SELECT
    CUSTOMER_ID,
    MAX(ORDER_DATE) AS LAST_ORDER_DATE,
    DATEDIFF('day', MAX(ORDER_DATE), CURRENT_DATE()) AS DAYS_INACTIVE,
    COUNT(DISTINCT ORDER_ID) AS TOTAL_ORDERS,
    SUM(TOTAL_AMOUNT) AS LIFETIME_VALUE,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE
FROM ORDERS
GROUP BY CUSTOMER_ID
HAVING DAYS_INACTIVE >= 30
ORDER BY LIFETIME_VALUE DESC, DAYS_INACTIVE DESC;

-- ============================================
-- 📦 SECTION 5: GESTION D'INVENTAIRE
-- ============================================

-- 5.1 - Alertes de stock bas (< 50 unités)
SELECT
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    CURRENT_STOCK_LEVEL,
    WAREHOUSE_LOCATION,
    LAST_ADJUSTMENT_TIMESTAMP,
    DATEDIFF('hour', LAST_ADJUSTMENT_TIMESTAMP, CURRENT_TIMESTAMP()) AS HOURS_SINCE_LAST_UPDATE,
    CASE
        WHEN CURRENT_STOCK_LEVEL = 0 THEN '🔴 RUPTURE'
        WHEN CURRENT_STOCK_LEVEL < 20 THEN '🟠 CRITIQUE'
        WHEN CURRENT_STOCK_LEVEL < 50 THEN '🟡 BAS'
        ELSE '🟢 OK'
    END AS STOCK_STATUS
FROM INVENTORY_CURRENT
WHERE CURRENT_STOCK_LEVEL < 50
ORDER BY CURRENT_STOCK_LEVEL ASC;

-- 5.2 - Prévision de rupture de stock (basée sur ventes moyennes)
WITH daily_sales AS (
    SELECT
        PRODUCT_ID,
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        ORDER_DATE,
        SUM(QUANTITY) AS DAILY_QUANTITY
    FROM ORDERS
    WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
    GROUP BY PRODUCT_ID, PRODUCT_NAME, PRODUCT_CATEGORY, ORDER_DATE
),
avg_sales AS (
    SELECT
        PRODUCT_ID,
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        AVG(DAILY_QUANTITY) AS AVG_DAILY_SALES,
        STDDEV(DAILY_QUANTITY) AS STDDEV_DAILY_SALES
    FROM daily_sales
    GROUP BY PRODUCT_ID, PRODUCT_NAME, PRODUCT_CATEGORY
)
SELECT
    i.PRODUCT_ID,
    i.PRODUCT_NAME,
    i.PRODUCT_CATEGORY,
    i.CURRENT_STOCK_LEVEL,
    ROUND(s.AVG_DAILY_SALES, 2) AS AVG_DAILY_SALES,
    ROUND(s.STDDEV_DAILY_SALES, 2) AS SALES_VOLATILITY,
    CASE
        WHEN s.AVG_DAILY_SALES > 0 THEN
            ROUND(i.CURRENT_STOCK_LEVEL / s.AVG_DAILY_SALES, 1)
        ELSE NULL
    END AS DAYS_OF_STOCK,
    CASE
        WHEN i.CURRENT_STOCK_LEVEL = 0 THEN '🔴 RUPTURE STOCK'
        WHEN i.CURRENT_STOCK_LEVEL / s.AVG_DAILY_SALES < 3 THEN '🔴 URGENT (< 3 jours)'
        WHEN i.CURRENT_STOCK_LEVEL / s.AVG_DAILY_SALES < 7 THEN '🟠 ATTENTION (< 7 jours)'
        WHEN i.CURRENT_STOCK_LEVEL / s.AVG_DAILY_SALES < 14 THEN '🟡 SURVEILLER (< 14 jours)'
        ELSE '🟢 OK'
    END AS STOCK_ALERT,
    i.WAREHOUSE_LOCATION,
    i.LAST_ADJUSTMENT_TIMESTAMP
FROM INVENTORY_CURRENT i
JOIN avg_sales s ON i.PRODUCT_ID = s.PRODUCT_ID
WHERE s.AVG_DAILY_SALES > 0
ORDER BY DAYS_OF_STOCK ASC NULLS FIRST;

-- 5.3 - Historique des ajustements d'inventaire (derniers 7 jours)
SELECT
    ADJUSTMENT_DATE,
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    ADJUSTMENT_TYPE,
    QUANTITY_CHANGE,
    NEW_STOCK_LEVEL,
    REASON,
    WAREHOUSE_LOCATION
FROM INVENTORY_HISTORY
WHERE ADJUSTMENT_DATE >= DATEADD('day', -7, CURRENT_DATE())
ORDER BY ADJUSTMENT_TIMESTAMP DESC;

-- 5.4 - Analyse des ajustements par type
SELECT
    ADJUSTMENT_TYPE,
    COUNT(*) AS ADJUSTMENT_COUNT,
    SUM(ABS(QUANTITY_CHANGE)) AS TOTAL_QUANTITY_MOVED,
    AVG(ABS(QUANTITY_CHANGE)) AS AVG_ADJUSTMENT_SIZE,
    COUNT(DISTINCT PRODUCT_ID) AS PRODUCTS_AFFECTED
FROM INVENTORY_HISTORY
WHERE ADJUSTMENT_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY ADJUSTMENT_TYPE
ORDER BY ADJUSTMENT_COUNT DESC;

-- 5.5 - Rotation des stocks (turnover rate)
WITH sales_30d AS (
    SELECT
        PRODUCT_ID,
        SUM(QUANTITY) AS UNITS_SOLD
    FROM ORDERS
    WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
    GROUP BY PRODUCT_ID
)
SELECT
    i.PRODUCT_ID,
    i.PRODUCT_NAME,
    i.PRODUCT_CATEGORY,
    i.CURRENT_STOCK_LEVEL,
    COALESCE(s.UNITS_SOLD, 0) AS UNITS_SOLD_30D,
    CASE
        WHEN i.CURRENT_STOCK_LEVEL > 0 THEN
            ROUND((COALESCE(s.UNITS_SOLD, 0) / i.CURRENT_STOCK_LEVEL) * 100, 2)
        ELSE NULL
    END AS TURNOVER_RATE_PCT,
    CASE
        WHEN COALESCE(s.UNITS_SOLD, 0) = 0 AND i.CURRENT_STOCK_LEVEL > 50 THEN '❌ Stock mort (pas de vente)'
        WHEN (s.UNITS_SOLD / i.CURRENT_STOCK_LEVEL) < 0.1 THEN '🐌 Rotation lente'
        WHEN (s.UNITS_SOLD / i.CURRENT_STOCK_LEVEL) < 0.5 THEN '🚶 Rotation normale'
        WHEN (s.UNITS_SOLD / i.CURRENT_STOCK_LEVEL) < 1.0 THEN '🏃 Rotation rapide'
        ELSE '🚀 Rotation très rapide'
    END AS TURNOVER_STATUS
FROM INVENTORY_CURRENT i
LEFT JOIN sales_30d s ON i.PRODUCT_ID = s.PRODUCT_ID
ORDER BY TURNOVER_RATE_PCT DESC NULLS LAST;

-- ============================================
-- 💰 SECTION 6: ANALYSE FINANCIÈRE
-- ============================================

-- 6.1 - Revenus par mode de paiement
SELECT
    PAYMENT_METHOD,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE,
    ROUND((SUM(TOTAL_AMOUNT) / (SELECT SUM(TOTAL_AMOUNT) FROM ORDERS)) * 100, 2) AS REVENUE_PCT
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY PAYMENT_METHOD
ORDER BY TOTAL_REVENUE DESC;

-- 6.2 - Panier moyen par catégorie
SELECT
    PRODUCT_CATEGORY,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE,
    AVG(TOTAL_AMOUNT) AS AVG_BASKET_SIZE,
    AVG(QUANTITY) AS AVG_QUANTITY_PER_ORDER,
    AVG(UNIT_PRICE) AS AVG_UNIT_PRICE
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY PRODUCT_CATEGORY
ORDER BY AVG_BASKET_SIZE DESC;

-- 6.3 - Évolution mensuelle (MoM - Month over Month)
WITH monthly_sales AS (
    SELECT
        DATE_TRUNC('month', ORDER_DATE) AS MONTH,
        COUNT(DISTINCT ORDER_ID) AS ORDERS,
        SUM(TOTAL_AMOUNT) AS REVENUE
    FROM ORDERS
    WHERE ORDER_DATE >= DATEADD('month', -6, CURRENT_DATE())
    GROUP BY DATE_TRUNC('month', ORDER_DATE)
)
SELECT
    MONTH,
    ORDERS,
    REVENUE,
    LAG(ORDERS, 1) OVER (ORDER BY MONTH) AS PREV_MONTH_ORDERS,
    LAG(REVENUE, 1) OVER (ORDER BY MONTH) AS PREV_MONTH_REVENUE,
    ROUND(((ORDERS - LAG(ORDERS, 1) OVER (ORDER BY MONTH)) / 
           LAG(ORDERS, 1) OVER (ORDER BY MONTH)) * 100, 2) AS ORDERS_GROWTH_PCT,
    ROUND(((REVENUE - LAG(REVENUE, 1) OVER (ORDER BY MONTH)) / 
           LAG(REVENUE, 1) OVER (ORDER BY MONTH)) * 100, 2) AS REVENUE_GROWTH_PCT
FROM monthly_sales
ORDER BY MONTH DESC;

-- ============================================
-- 🎯 SECTION 7: ANALYSE DE PERFORMANCE PRODUIT
-- ============================================

-- 7.1 - Produits les plus rentables
SELECT
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(QUANTITY) AS UNITS_SOLD,
    AVG(UNIT_PRICE) AS AVG_PRICE,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE,
    ROUND(SUM(TOTAL_AMOUNT) / SUM(QUANTITY), 2) AS REVENUE_PER_UNIT
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY PRODUCT_NAME, PRODUCT_CATEGORY
HAVING UNITS_SOLD >= 5
ORDER BY TOTAL_REVENUE DESC
LIMIT 20;

-- 7.2 - Analyse ABC (80/20 rule - Pareto)
WITH product_revenue AS (
    SELECT
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        SUM(TOTAL_AMOUNT) AS REVENUE
    FROM ORDERS
    WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
    GROUP BY PRODUCT_NAME, PRODUCT_CATEGORY
),
cumulative AS (
    SELECT
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        REVENUE,
        SUM(REVENUE) OVER (ORDER BY REVENUE DESC) AS CUMULATIVE_REVENUE,
        SUM(REVENUE) OVER () AS TOTAL_REVENUE
    FROM product_revenue
)
SELECT
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    REVENUE,
    ROUND((CUMULATIVE_REVENUE / TOTAL_REVENUE) * 100, 2) AS CUMULATIVE_PCT,
    CASE
        WHEN (CUMULATIVE_REVENUE / TOTAL_REVENUE) <= 0.80 THEN 'A - Top 80%'
        WHEN (CUMULATIVE_REVENUE / TOTAL_REVENUE) <= 0.95 THEN 'B - Next 15%'
        ELSE 'C - Bottom 5%'
    END AS ABC_CLASS
FROM cumulative
ORDER BY REVENUE DESC;

-- 7.3 - Produits en déclin (baisse de ventes vs période précédente)
WITH current_period AS (
    SELECT
        PRODUCT_ID,
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        SUM(QUANTITY) AS CURRENT_SALES
    FROM ORDERS
    WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
    GROUP BY PRODUCT_ID, PRODUCT_NAME, PRODUCT_CATEGORY
),
previous_period AS (
    SELECT
        PRODUCT_ID,
        SUM(QUANTITY) AS PREVIOUS_SALES
    FROM ORDERS
    WHERE ORDER_DATE >= DATEADD('day', -60, CURRENT_DATE())
        AND ORDER_DATE < DATEADD('day', -30, CURRENT_DATE())
    GROUP BY PRODUCT_ID
)
SELECT
    c.PRODUCT_NAME,
    c.PRODUCT_CATEGORY,
    p.PREVIOUS_SALES,
    c.CURRENT_SALES,
    (c.CURRENT_SALES - p.PREVIOUS_SALES) AS SALES_CHANGE,
    ROUND(((c.CURRENT_SALES - p.PREVIOUS_SALES) / p.PREVIOUS_SALES) * 100, 2) AS CHANGE_PCT
FROM current_period c
JOIN previous_period p ON c.PRODUCT_ID = p.PRODUCT_ID
WHERE p.PREVIOUS_SALES > 0
    AND ((c.CURRENT_SALES - p.PREVIOUS_SALES) / p.PREVIOUS_SALES) < -0.20  -- Baisse > 20%
ORDER BY CHANGE_PCT ASC;

-- ============================================
-- 🔔 SECTION 8: ALERTES ET MONITORING
-- ============================================

-- 8.1 - Vue d'ensemble des alertes
SELECT
    'Stock critique (< 20 unités)' AS ALERT_TYPE,
    COUNT(*) AS ALERT_COUNT,
    '🔴 URGENT' AS PRIORITY
FROM INVENTORY_CURRENT
WHERE CURRENT_STOCK_LEVEL < 20

UNION ALL

SELECT
    'Stock bas (20-50 unités)',
    COUNT(*),
    '🟠 IMPORTANT'
FROM INVENTORY_CURRENT
WHERE CURRENT_STOCK_LEVEL BETWEEN 20 AND 50

UNION ALL

SELECT
    'Clients inactifs (30+ jours)',
    COUNT(DISTINCT CUSTOMER_ID),
    '🟡 MOYEN'
FROM ORDERS
GROUP BY CUSTOMER_ID
HAVING DATEDIFF('day', MAX(ORDER_DATE), CURRENT_DATE()) >= 30

UNION ALL

SELECT
    'Produits sans vente (7 derniers jours)',
    COUNT(DISTINCT i.PRODUCT_ID),
    '🟢 INFO'
FROM INVENTORY_CURRENT i
LEFT JOIN ORDERS o ON i.PRODUCT_ID = o.PRODUCT_ID
    AND o.ORDER_DATE >= DATEADD('day', -7, CURRENT_DATE())
WHERE o.PRODUCT_ID IS NULL;

-- 8.2 - Rapport de santé du pipeline
SELECT
    'RAW_EVENTS_STREAM' AS LAYER,
    COUNT(*) AS ROW_COUNT,
    MAX(INGESTION_TIMESTAMP) AS LAST_UPDATE,
    DATEDIFF('minute', MAX(INGESTION_TIMESTAMP), CURRENT_TIMESTAMP()) AS MINUTES_SINCE_LAST_UPDATE
FROM RAW_DATA.RAW_EVENTS_STREAM

UNION ALL

SELECT
    'ORDERS (PRODUCTION)',
    COUNT(*),
    MAX(UPDATED_AT),
    DATEDIFF('minute', MAX(UPDATED_AT), CURRENT_TIMESTAMP())
FROM ORDERS

UNION ALL

SELECT
    'INVENTORY_CURRENT',
    COUNT(*),
    MAX(UPDATED_AT),
    DATEDIFF('minute', MAX(UPDATED_AT), CURRENT_TIMESTAMP())
FROM INVENTORY_CURRENT;

-- ============================================
-- 📊 SECTION 9: VUES MATÉRIALISÉES (RECOMMANDÉ)
-- ============================================

-- Créer des vues pour accélérer les dashboards

-- Vue 1: KPI quotidiens
CREATE OR REPLACE VIEW VW_DAILY_KPI AS
SELECT
    ORDER_DATE,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    COUNT(DISTINCT CUSTOMER_ID) AS CUSTOMER_COUNT,
    SUM(TOTAL_AMOUNT) AS DAILY_REVENUE,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE,
    SUM(QUANTITY) AS UNITS_SOLD
FROM ORDERS
GROUP BY ORDER_DATE;

-- Vue 2: Performance par produit
CREATE OR REPLACE VIEW VW_PRODUCT_PERFORMANCE AS
SELECT
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    COUNT(DISTINCT ORDER_ID) AS TOTAL_ORDERS,
    SUM(QUANTITY) AS TOTAL_UNITS_SOLD,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE,
    AVG(UNIT_PRICE) AS AVG_PRICE,
    MAX(ORDER_DATE) AS LAST_SALE_DATE
FROM ORDERS
GROUP BY PRODUCT_ID, PRODUCT_NAME, PRODUCT_CATEGORY;

-- Vue 3: Snapshot de l'inventaire avec alertes
CREATE OR REPLACE VIEW VW_INVENTORY_ALERTS AS
SELECT
    i.PRODUCT_ID,
    i.PRODUCT_NAME,
    i.PRODUCT_CATEGORY,
    i.CURRENT_STOCK_LEVEL,
    i.WAREHOUSE_LOCATION,
    i.LAST_ADJUSTMENT_TIMESTAMP,
    CASE
        WHEN i.CURRENT_STOCK_LEVEL = 0 THEN '🔴 RUPTURE'
        WHEN i.CURRENT_STOCK_LEVEL < 20 THEN '🟠 CRITIQUE'
        WHEN i.CURRENT_STOCK_LEVEL < 50 THEN '🟡 BAS'
        ELSE '🟢 OK'
    END AS STOCK_STATUS,
    COALESCE(s.UNITS_SOLD_30D, 0) AS SALES_LAST_30_DAYS
FROM INVENTORY_CURRENT i
LEFT JOIN (
    SELECT PRODUCT_ID, SUM(QUANTITY) AS UNITS_SOLD_30D
    FROM ORDERS
    WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
    GROUP BY PRODUCT_ID
) s ON i.PRODUCT_ID = s.PRODUCT_ID;

-- ============================================
-- 🎓 SECTION 10: EXEMPLES D'USAGE
-- ============================================

-- Exemple 1: Dashboard manager (vue d'ensemble)
SELECT * FROM VW_DAILY_KPI
WHERE ORDER_DATE >= DATEADD('day', -7, CURRENT_DATE())
ORDER BY ORDER_DATE DESC;

-- Exemple 2: Rapport de vente hebdomadaire
SELECT
    DATE_TRUNC('week', ORDER_DATE) AS WEEK,
    PRODUCT_CATEGORY,
    SUM(TOTAL_AMOUNT) AS WEEKLY_REVENUE
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('week', -4, CURRENT_DATE())
GROUP BY 1, 2
ORDER BY 1 DESC, 3 DESC;

-- Exemple 3: Liste de commandes à préparer (aujourd'hui)
SELECT
    ORDER_ID,
    ORDER_TIMESTAMP,
    CUSTOMER_ID,
    PRODUCT_NAME,
    QUANTITY,
    TOTAL_AMOUNT,
    SHIPPING_ADDRESS,
    PAYMENT_METHOD
FROM ORDERS
WHERE ORDER_DATE = CURRENT_DATE()
ORDER BY ORDER_TIMESTAMP DESC;

-- ============================================
-- FIN DES REQUÊTES ANALYTIQUES
-- ============================================
-- Pour toute question ou personnalisation :
-- 📧 Contact : data-team@lescavesdalbert.com
-- 📚 Documentation : SNOWFLAKE_AUTOMATION_GUIDE.md
