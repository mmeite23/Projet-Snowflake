-- ============================================
-- ðŸ· LES CAVES D'ALBERT - SNOWFLAKE TASKS & STREAMS (VERSION FINALE CORRIGÃ‰E)
-- ============================================
-- Architecture: RAW â†’ STAGING â†’ PRODUCTION
-- Traitement automatisÃ© avec CDC (Change Data Capture)
-- 
-- ðŸ”§ CORRECTIONS APPLIQUÃ‰ES:
-- 1. Utilisation correcte des noms de colonnes : EVENT_CONTENT (pas EVENT_DATA)
-- 2. PRODUCT_ID et CUSTOMER_ID sont des colonnes directes (pas dans JSON)
-- 3. Ajout du mot-clÃ© WHEN manquant dans TASK 4
-- 4. Simplification de l'architecture avec un seul stream RAW
-- 5. Deux streams sÃ©parÃ©s pour STAGING.STG_INVENTORY_ADJUSTMENTS

USE DATABASE CAVES_ALBERT_DB;
USE SCHEMA RAW_DATA;

-- S'assurer que les schÃ©mas existent
CREATE SCHEMA IF NOT EXISTS STAGING;
CREATE SCHEMA IF NOT EXISTS PRODUCTION;

-- ============================================
-- 1ï¸âƒ£ CRÃ‰ATION DES TABLES DE STAGING ET PRODUCTION
-- ============================================

-- Table de staging pour les commandes
CREATE TABLE IF NOT EXISTS STAGING.STG_ORDERS (
    ORDER_ID VARCHAR(50),
    EVENT_TYPE VARCHAR(50),
    EVENT_TIMESTAMP TIMESTAMP_NTZ,
    CUSTOMER_ID VARCHAR(50),
    PRODUCT_ID VARCHAR(50),
    PRODUCT_NAME VARCHAR(200),
    PRODUCT_CATEGORY VARCHAR(50),
    QUANTITY NUMBER(10,0),
    UNIT_PRICE NUMBER(10,2),
    TOTAL_AMOUNT NUMBER(10,2),
    PAYMENT_METHOD VARCHAR(50),
    SHIPPING_ADDRESS VARCHAR(500),
    INGESTION_TIMESTAMP TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- Table de staging pour les ajustements d'inventaire
CREATE TABLE IF NOT EXISTS STAGING.STG_INVENTORY_ADJUSTMENTS (
    ADJUSTMENT_ID VARCHAR(50),
    EVENT_TYPE VARCHAR(50),
    EVENT_TIMESTAMP TIMESTAMP_NTZ,
    PRODUCT_ID VARCHAR(50),
    PRODUCT_NAME VARCHAR(200),
    PRODUCT_CATEGORY VARCHAR(50),
    ADJUSTMENT_TYPE VARCHAR(50),
    QUANTITY_CHANGE NUMBER(10,0),
    NEW_STOCK_LEVEL NUMBER(10,0),
    REASON VARCHAR(200),
    WAREHOUSE_LOCATION VARCHAR(100),
    INGESTION_TIMESTAMP TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- Table de production pour les commandes
CREATE TABLE IF NOT EXISTS PRODUCTION.ORDERS (
    ORDER_ID VARCHAR(50) PRIMARY KEY,
    ORDER_DATE DATE,
    ORDER_TIMESTAMP TIMESTAMP_NTZ,
    CUSTOMER_ID VARCHAR(50),
    PRODUCT_ID VARCHAR(50),
    PRODUCT_NAME VARCHAR(200),
    PRODUCT_CATEGORY VARCHAR(50),
    QUANTITY NUMBER(10,0),
    UNIT_PRICE NUMBER(10,2),
    TOTAL_AMOUNT NUMBER(10,2),
    PAYMENT_METHOD VARCHAR(50),
    SHIPPING_ADDRESS VARCHAR(500),
    CREATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    UPDATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- Table de production pour l'inventaire en temps rÃ©el
CREATE TABLE IF NOT EXISTS PRODUCTION.INVENTORY_CURRENT (
    PRODUCT_ID VARCHAR(50) PRIMARY KEY,
    PRODUCT_NAME VARCHAR(200),
    PRODUCT_CATEGORY VARCHAR(50),
    CURRENT_STOCK_LEVEL NUMBER(10,0),
    LAST_ADJUSTMENT_TIMESTAMP TIMESTAMP_NTZ,
    WAREHOUSE_LOCATION VARCHAR(100),
    UPDATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- Table de production pour l'historique des ajustements d'inventaire
CREATE TABLE IF NOT EXISTS PRODUCTION.INVENTORY_HISTORY (
    ADJUSTMENT_ID VARCHAR(50) PRIMARY KEY,
    ADJUSTMENT_DATE DATE,
    ADJUSTMENT_TIMESTAMP TIMESTAMP_NTZ,
    PRODUCT_ID VARCHAR(50),
    PRODUCT_NAME VARCHAR(200),
    PRODUCT_CATEGORY VARCHAR(50),
    ADJUSTMENT_TYPE VARCHAR(50),
    QUANTITY_CHANGE NUMBER(10,0),
    NEW_STOCK_LEVEL NUMBER(10,0),
    REASON VARCHAR(200),
    WAREHOUSE_LOCATION VARCHAR(100),
    CREATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- ============================================
-- 2ï¸âƒ£ CRÃ‰ATION DES STREAMS (CDC)
-- ============================================

-- Stream principal sur la table RAW pour capturer tous les Ã©vÃ©nements
CREATE OR REPLACE STREAM STREAM_RAW_EVENTS
ON TABLE RAW_EVENTS_STREAM
APPEND_ONLY = TRUE
COMMENT = 'ðŸ”„ Capture TOUS les Ã©vÃ©nements de la table RAW_EVENTS_STREAM';

-- Stream sur la table de staging des commandes
CREATE OR REPLACE STREAM STREAM_STG_ORDERS
ON TABLE STAGING.STG_ORDERS
COMMENT = 'ðŸ”„ Stream pour propager les commandes STAGING â†’ PRODUCTION';

-- Deux streams sÃ©parÃ©s sur la table de staging d'inventaire
-- (car deux tasks diffÃ©rentes lisent cette table)
CREATE OR REPLACE STREAM STREAM_STG_INVENTORY_FOR_HISTORY
ON TABLE STAGING.STG_INVENTORY_ADJUSTMENTS
COMMENT = 'ðŸ”„ Stream pour PRODUCTION.INVENTORY_HISTORY';

CREATE OR REPLACE STREAM STREAM_STG_INVENTORY_FOR_CURRENT
ON TABLE STAGING.STG_INVENTORY_ADJUSTMENTS
COMMENT = 'ðŸ”„ Stream pour PRODUCTION.INVENTORY_CURRENT';

-- ============================================
-- 3ï¸âƒ£ CRÃ‰ATION DES TASKS
-- ============================================

-- TASK 1: Distribution RAW â†’ STAGING (Orders et Inventory)
-- Cette task utilise INSERT ALL pour router les Ã©vÃ©nements vers les bonnes tables
CREATE OR REPLACE TASK TASK_RAW_TO_STAGING_DISTRIBUTOR
    WAREHOUSE = COMPUTE_WH
    SCHEDULE = '1 MINUTE'
    COMMENT = 'â±ï¸ Distribue les Ã©vÃ©nements RAW â†’ STG_ORDERS et STG_INVENTORY'
WHEN
    SYSTEM$STREAM_HAS_DATA('STREAM_RAW_EVENTS')
AS
INSERT ALL
    -- Condition 1: Si ORDER_CREATED â†’ insÃ©rer dans STG_ORDERS
    WHEN EVENT_TYPE = 'ORDER_CREATED' THEN
        INTO STAGING.STG_ORDERS (
            ORDER_ID, EVENT_TYPE, EVENT_TIMESTAMP, CUSTOMER_ID, PRODUCT_ID, 
            PRODUCT_NAME, PRODUCT_CATEGORY, QUANTITY, UNIT_PRICE, TOTAL_AMOUNT, 
            PAYMENT_METHOD, SHIPPING_ADDRESS
        )
        VALUES (
            ORDER_ID_VAL, EVENT_TYPE, EVENT_TIMESTAMP, CUSTOMER_ID_VAL, PRODUCT_ID_VAL, 
            PRODUCT_NAME_VAL, PRODUCT_CATEGORY_VAL, QUANTITY_VAL, UNIT_PRICE_VAL, 
            TOTAL_AMOUNT_VAL, PAYMENT_METHOD_VAL, SHIPPING_ADDRESS_VAL
        )
    -- Condition 2: Si INVENTORY_ADJUSTED â†’ insÃ©rer dans STG_INVENTORY_ADJUSTMENTS
    WHEN EVENT_TYPE = 'INVENTORY_ADJUSTED' THEN
        INTO STAGING.STG_INVENTORY_ADJUSTMENTS (
            ADJUSTMENT_ID, EVENT_TYPE, EVENT_TIMESTAMP, PRODUCT_ID, PRODUCT_NAME, 
            PRODUCT_CATEGORY, ADJUSTMENT_TYPE, QUANTITY_CHANGE, NEW_STOCK_LEVEL, 
            REASON, WAREHOUSE_LOCATION
        )
        VALUES (
            ADJUSTMENT_ID_VAL, EVENT_TYPE, EVENT_TIMESTAMP, PRODUCT_ID_VAL, 
            PRODUCT_NAME_VAL, PRODUCT_CATEGORY_VAL, ADJUSTMENT_TYPE_VAL, 
            QUANTITY_CHANGE_VAL, NEW_STOCK_LEVEL_VAL, REASON_VAL, WAREHOUSE_LOCATION_VAL
        )
-- Source: extraction des donnÃ©es depuis STREAM_RAW_EVENTS
SELECT 
    EVENT_TYPE,
    INGESTION_TIME AS EVENT_TIMESTAMP,
    -- Colonnes directes (pas dans JSON)
    CAST(CUSTOMER_ID AS VARCHAR) AS CUSTOMER_ID_VAL,
    CAST(PRODUCT_ID AS VARCHAR) AS PRODUCT_ID_VAL,
    -- Extraction depuis EVENT_CONTENT pour ORDER_CREATED
    -- ðŸ”§ CORRECTION: Utilisation des vrais noms de champs du producer
    EVENT_CONTENT:order_line_id::VARCHAR AS ORDER_ID_VAL,
    EVENT_CONTENT:product_name::VARCHAR AS PRODUCT_NAME_VAL,
    EVENT_CONTENT:category::VARCHAR AS PRODUCT_CATEGORY_VAL,
    EVENT_CONTENT:quantity::NUMBER AS QUANTITY_VAL,
    EVENT_CONTENT:unit_price::NUMBER AS UNIT_PRICE_VAL,
    EVENT_CONTENT:total_price::NUMBER AS TOTAL_AMOUNT_VAL,
    EVENT_CONTENT:sales_channel::VARCHAR AS PAYMENT_METHOD_VAL,
    CONCAT('Bottle: ', EVENT_CONTENT:bottle_size_l::VARCHAR, 'L - Discount: â‚¬', EVENT_CONTENT:discount::VARCHAR) AS SHIPPING_ADDRESS_VAL,
    -- Extraction depuis EVENT_CONTENT pour INVENTORY_ADJUSTED
    EVENT_CONTENT:event_id::VARCHAR AS ADJUSTMENT_ID_VAL,
    EVENT_CONTENT:adjustment_type::VARCHAR AS ADJUSTMENT_TYPE_VAL,
    EVENT_CONTENT:quantity_change::NUMBER AS QUANTITY_CHANGE_VAL,
    NULL AS NEW_STOCK_LEVEL_VAL,  -- Non disponible dans les Ã©vÃ©nements
    EVENT_CONTENT:adjustment_type::VARCHAR AS REASON_VAL,
    EVENT_CONTENT:warehouse_location::VARCHAR AS WAREHOUSE_LOCATION_VAL
FROM STREAM_RAW_EVENTS
WHERE METADATA$ACTION = 'INSERT' 
  AND METADATA$ISUPDATE = FALSE
  AND EVENT_TYPE IN ('ORDER_CREATED', 'INVENTORY_ADJUSTED');


-- TASK 2: STAGING â†’ PRODUCTION (Commandes)
CREATE OR REPLACE TASK TASK_STAGING_TO_PROD_ORDERS
    WAREHOUSE = COMPUTE_WH
    AFTER TASK_RAW_TO_STAGING_DISTRIBUTOR
WHEN
    SYSTEM$STREAM_HAS_DATA('STREAM_STG_ORDERS')
AS
MERGE INTO PRODUCTION.ORDERS AS target
USING (
    SELECT
        ORDER_ID,
        DATE(EVENT_TIMESTAMP) AS ORDER_DATE,
        EVENT_TIMESTAMP AS ORDER_TIMESTAMP,
        CUSTOMER_ID,
        PRODUCT_ID,
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        QUANTITY,
        UNIT_PRICE,
        TOTAL_AMOUNT,
        PAYMENT_METHOD,
        SHIPPING_ADDRESS,
        CURRENT_TIMESTAMP() AS UPDATED_AT
    FROM STREAM_STG_ORDERS
    WHERE METADATA$ACTION = 'INSERT'
      AND METADATA$ISUPDATE = FALSE
) AS source
ON target.ORDER_ID = source.ORDER_ID
WHEN MATCHED THEN
    UPDATE SET
        target.QUANTITY = source.QUANTITY,
        target.TOTAL_AMOUNT = source.TOTAL_AMOUNT,
        target.UPDATED_AT = source.UPDATED_AT
WHEN NOT MATCHED THEN
    INSERT (
        ORDER_ID, ORDER_DATE, ORDER_TIMESTAMP, CUSTOMER_ID, PRODUCT_ID, 
        PRODUCT_NAME, PRODUCT_CATEGORY, QUANTITY, UNIT_PRICE, TOTAL_AMOUNT, 
        PAYMENT_METHOD, SHIPPING_ADDRESS, UPDATED_AT
    )
    VALUES (
        source.ORDER_ID, source.ORDER_DATE, source.ORDER_TIMESTAMP, source.CUSTOMER_ID, source.PRODUCT_ID, 
        source.PRODUCT_NAME, source.PRODUCT_CATEGORY, source.QUANTITY, source.UNIT_PRICE, source.TOTAL_AMOUNT, 
        source.PAYMENT_METHOD, source.SHIPPING_ADDRESS, source.UPDATED_AT
    );


-- TASK 3: STAGING â†’ PRODUCTION (Inventaire - Historique)
-- ðŸ”§ CORRECTION: Ajout du mot-clÃ© WHEN manquant
CREATE OR REPLACE TASK TASK_STAGING_TO_PROD_INVENTORY_HISTORY
    WAREHOUSE = COMPUTE_WH
    AFTER TASK_RAW_TO_STAGING_DISTRIBUTOR
WHEN
    SYSTEM$STREAM_HAS_DATA('STREAM_STG_INVENTORY_FOR_HISTORY')
AS
INSERT INTO PRODUCTION.INVENTORY_HISTORY (
    ADJUSTMENT_ID, ADJUSTMENT_DATE, ADJUSTMENT_TIMESTAMP, PRODUCT_ID, PRODUCT_NAME,
    PRODUCT_CATEGORY, ADJUSTMENT_TYPE, QUANTITY_CHANGE, NEW_STOCK_LEVEL, REASON, WAREHOUSE_LOCATION
)
SELECT
    ADJUSTMENT_ID,
    DATE(EVENT_TIMESTAMP) AS ADJUSTMENT_DATE,
    EVENT_TIMESTAMP AS ADJUSTMENT_TIMESTAMP,
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    ADJUSTMENT_TYPE,
    QUANTITY_CHANGE,
    NEW_STOCK_LEVEL,
    REASON,
    WAREHOUSE_LOCATION
FROM STREAM_STG_INVENTORY_FOR_HISTORY
WHERE METADATA$ACTION = 'INSERT'
  AND METADATA$ISUPDATE = FALSE;


-- TASK 4: STAGING â†’ PRODUCTION (Inventaire - Ã‰tat Actuel)
CREATE OR REPLACE TASK TASK_STAGING_TO_PROD_INVENTORY_CURRENT
    WAREHOUSE = COMPUTE_WH
    AFTER TASK_STAGING_TO_PROD_INVENTORY_HISTORY
WHEN
    SYSTEM$STREAM_HAS_DATA('STREAM_STG_INVENTORY_FOR_CURRENT')
AS
MERGE INTO PRODUCTION.INVENTORY_CURRENT AS target
USING (
    SELECT
        PRODUCT_ID,
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        NEW_STOCK_LEVEL,
        EVENT_TIMESTAMP AS LAST_ADJUSTMENT_TIMESTAMP,
        WAREHOUSE_LOCATION,
        CURRENT_TIMESTAMP() AS UPDATED_AT
    FROM STREAM_STG_INVENTORY_FOR_CURRENT
    WHERE METADATA$ACTION = 'INSERT'
      AND METADATA$ISUPDATE = FALSE
    QUALIFY ROW_NUMBER() OVER (PARTITION BY PRODUCT_ID ORDER BY EVENT_TIMESTAMP DESC) = 1
) AS source
ON target.PRODUCT_ID = source.PRODUCT_ID
WHEN MATCHED THEN
    UPDATE SET
        target.PRODUCT_NAME = source.PRODUCT_NAME,
        target.PRODUCT_CATEGORY = source.PRODUCT_CATEGORY,
        target.CURRENT_STOCK_LEVEL = source.NEW_STOCK_LEVEL,
        target.LAST_ADJUSTMENT_TIMESTAMP = source.LAST_ADJUSTMENT_TIMESTAMP,
        target.WAREHOUSE_LOCATION = source.WAREHOUSE_LOCATION,
        target.UPDATED_AT = source.UPDATED_AT
WHEN NOT MATCHED THEN
    INSERT (
        PRODUCT_ID, PRODUCT_NAME, PRODUCT_CATEGORY, CURRENT_STOCK_LEVEL,
        LAST_ADJUSTMENT_TIMESTAMP, WAREHOUSE_LOCATION, UPDATED_AT
    )
    VALUES (
        source.PRODUCT_ID, source.PRODUCT_NAME, source.PRODUCT_CATEGORY, source.NEW_STOCK_LEVEL,
        source.LAST_ADJUSTMENT_TIMESTAMP, source.WAREHOUSE_LOCATION, source.UPDATED_AT
    );


-- ============================================
-- 4ï¸âƒ£ ACTIVATION DES TASKS (DAG)
-- ============================================
-- Architecture du DAG :
--
-- 1. TASK_RAW_TO_STAGING_DISTRIBUTOR (toutes les 1 min) [RACINE]
--    â”œâ”€â”€ 2. TASK_STAGING_TO_PROD_ORDERS (aprÃ¨s 1)
--    â””â”€â”€ 3. TASK_STAGING_TO_PROD_INVENTORY_HISTORY (aprÃ¨s 1)
--         â””â”€â”€ 4. TASK_STAGING_TO_PROD_INVENTORY_CURRENT (aprÃ¨s 3)

-- Activer les tasks enfants d'abord, puis les parents
ALTER TASK TASK_STAGING_TO_PROD_INVENTORY_CURRENT RESUME;
ALTER TASK TASK_STAGING_TO_PROD_INVENTORY_HISTORY RESUME;
ALTER TASK TASK_STAGING_TO_PROD_ORDERS RESUME;
ALTER TASK TASK_RAW_TO_STAGING_DISTRIBUTOR RESUME;

-- ============================================
-- 5ï¸âƒ£ MONITORING ET VÃ‰RIFICATION
-- ============================================

-- VÃ©rifier l'Ã©tat des tasks
SHOW TASKS IN DATABASE CAVES_ALBERT_DB;

-- Voir l'historique d'exÃ©cution des tasks (derniÃ¨re heure)
SELECT
    NAME AS TASK_NAME,
    STATE,
    SCHEDULED_TIME,
    COMPLETED_TIME,
    DATEDIFF('second', SCHEDULED_TIME, COMPLETED_TIME) AS DURATION_SECONDS,
    ERROR_CODE,
    ERROR_MESSAGE
FROM TABLE(INFORMATION_SCHEMA.TASK_HISTORY(
    SCHEDULED_TIME_RANGE_START => DATEADD('hour', -1, CURRENT_TIMESTAMP())
))
WHERE NAME IN (
    'TASK_RAW_TO_STAGING_DISTRIBUTOR',
    'TASK_STAGING_TO_PROD_ORDERS',
    'TASK_STAGING_TO_PROD_INVENTORY_HISTORY',
    'TASK_STAGING_TO_PROD_INVENTORY_CURRENT'
)
ORDER BY SCHEDULED_TIME DESC
LIMIT 20;

-- VÃ©rifier si les streams ont des donnÃ©es en attente
SELECT 'STREAM_RAW_EVENTS' AS STREAM_NAME, SYSTEM$STREAM_HAS_DATA('STREAM_RAW_EVENTS') AS HAS_DATA
UNION ALL
SELECT 'STREAM_STG_ORDERS', SYSTEM$STREAM_HAS_DATA('STREAM_STG_ORDERS')
UNION ALL
SELECT 'STREAM_STG_INVENTORY_FOR_HISTORY', SYSTEM$STREAM_HAS_DATA('STREAM_STG_INVENTORY_FOR_HISTORY')
UNION ALL
SELECT 'STREAM_STG_INVENTORY_FOR_CURRENT', SYSTEM$STREAM_HAS_DATA('STREAM_STG_INVENTORY_FOR_CURRENT');

-- Compter les lignes dans chaque stream
SELECT 'STREAM_RAW_EVENTS' AS STREAM_NAME, COUNT(*) AS PENDING_ROWS FROM STREAM_RAW_EVENTS
UNION ALL
SELECT 'STREAM_STG_ORDERS', COUNT(*) FROM STREAM_STG_ORDERS
UNION ALL
SELECT 'STREAM_STG_INVENTORY_FOR_HISTORY', COUNT(*) FROM STREAM_STG_INVENTORY_FOR_HISTORY
UNION ALL
SELECT 'STREAM_STG_INVENTORY_FOR_CURRENT', COUNT(*) FROM STREAM_STG_INVENTORY_FOR_CURRENT;

-- Vue d'ensemble du pipeline (nombre de lignes par table)
SELECT 'RAW' AS LAYER, 'RAW_EVENTS_STREAM' AS TABLE_NAME, COUNT(*) AS ROWS 
FROM RAW_DATA.RAW_EVENTS_STREAM
UNION ALL
SELECT 'STAGING', 'STG_ORDERS', COUNT(*) FROM STAGING.STG_ORDERS
UNION ALL
SELECT 'STAGING', 'STG_INVENTORY_ADJUSTMENTS', COUNT(*) FROM STAGING.STG_INVENTORY_ADJUSTMENTS
UNION ALL
SELECT 'PRODUCTION', 'ORDERS', COUNT(*) FROM PRODUCTION.ORDERS
UNION ALL
SELECT 'PRODUCTION', 'INVENTORY_HISTORY', COUNT(*) FROM PRODUCTION.INVENTORY_HISTORY
UNION ALL
SELECT 'PRODUCTION', 'INVENTORY_CURRENT', COUNT(*) FROM PRODUCTION.INVENTORY_CURRENT
ORDER BY LAYER, TABLE_NAME;

-- ============================================
-- 6ï¸âƒ£ COMMANDES DE GESTION
-- ============================================

-- Suspendre toutes les tasks (si nÃ©cessaire)
/*
ALTER TASK TASK_RAW_TO_STAGING_DISTRIBUTOR SUSPEND;
ALTER TASK TASK_STAGING_TO_PROD_ORDERS SUSPEND;
ALTER TASK TASK_STAGING_TO_PROD_INVENTORY_HISTORY SUSPEND;
ALTER TASK TASK_STAGING_TO_PROD_INVENTORY_CURRENT SUSPEND;
*/

-- ExÃ©cuter manuellement une task (pour tester)
/*
EXECUTE TASK TASK_RAW_TO_STAGING_DISTRIBUTOR;
*/

-- ============================================
-- 7ï¸âƒ£ REQUÃŠTES ANALYTIQUES
-- ============================================

-- Top 10 des produits les plus vendus
SELECT
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    COUNT(*) AS ORDER_COUNT,
    SUM(QUANTITY) AS TOTAL_QUANTITY,
    ROUND(SUM(TOTAL_AMOUNT), 2) AS TOTAL_REVENUE
FROM PRODUCTION.ORDERS
GROUP BY PRODUCT_NAME, PRODUCT_CATEGORY
ORDER BY TOTAL_REVENUE DESC
LIMIT 10;

-- Ã‰tat actuel de l'inventaire par catÃ©gorie
SELECT
    PRODUCT_CATEGORY,
    COUNT(DISTINCT PRODUCT_ID) AS PRODUCT_COUNT,
    SUM(CURRENT_STOCK_LEVEL) AS TOTAL_STOCK,
    ROUND(AVG(CURRENT_STOCK_LEVEL), 0) AS AVG_STOCK_PER_PRODUCT
FROM PRODUCTION.INVENTORY_CURRENT
GROUP BY PRODUCT_CATEGORY
ORDER BY TOTAL_STOCK DESC;

-- Tendance des ventes par jour (derniers 30 jours)
SELECT
    ORDER_DATE,
    COUNT(*) AS ORDER_COUNT,
    ROUND(SUM(TOTAL_AMOUNT), 2) AS DAILY_REVENUE
FROM PRODUCTION.ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY ORDER_DATE
ORDER BY ORDER_DATE DESC;

-- Alertes : Produits avec stock faible (< 50 unitÃ©s)
SELECT
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    CURRENT_STOCK_LEVEL,
    WAREHOUSE_LOCATION,
    LAST_ADJUSTMENT_TIMESTAMP,
    TIMESTAMPDIFF('hour', LAST_ADJUSTMENT_TIMESTAMP, CURRENT_TIMESTAMP()) AS HOURS_SINCE_LAST_UPDATE
FROM PRODUCTION.INVENTORY_CURRENT
WHERE CURRENT_STOCK_LEVEL < 50
ORDER BY CURRENT_STOCK_LEVEL ASC;

-- ============================================
-- ðŸ“Š RÃ‰SUMÃ‰ DES CORRECTIONS
-- ============================================
-- âœ… 1. Utilisation de EVENT_CONTENT au lieu de EVENT_DATA
-- âœ… 2. PRODUCT_ID et CUSTOMER_ID sont des colonnes directes (CAST en VARCHAR)
-- âœ… 3. Ajout du mot-clÃ© WHEN dans TASK_STAGING_TO_PROD_INVENTORY_HISTORY
-- âœ… 4. Deux streams sÃ©parÃ©s pour STG_INVENTORY_ADJUSTMENTS (Ã©vite conflits de consommation)
-- âœ… 5. Architecture simplifiÃ©e avec un seul stream sur RAW_EVENTS_STREAM
-- âœ… 6. Ajout de INGESTION_TIME comme EVENT_TIMESTAMP (timestamp d'insertion Snowflake)
