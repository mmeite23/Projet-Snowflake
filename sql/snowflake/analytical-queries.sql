-- ============================================
-- üç∑ LES CAVES D'ALBERT - REQU√äTES ANALYTIQUES
-- ============================================
-- Collection de requ√™tes pr√™tes √† l'emploi pour l'analyse business

USE DATABASE CAVES_ALBERT_DB;
USE SCHEMA PRODUCTION;

-- ============================================
-- üìä SECTION 1: KPI TEMPS R√âEL
-- ============================================

-- 1.1 - Dashboard du jour (m√©triques cl√©s)
SELECT
    'üìÖ Aujourd''hui' AS PERIOD,
    COUNT(DISTINCT ORDER_ID) AS TOTAL_ORDERS,
    COUNT(DISTINCT CUSTOMER_ID) AS UNIQUE_CUSTOMERS,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE,
    SUM(QUANTITY) AS TOTAL_UNITS_SOLD
FROM ORDERS
WHERE ORDER_DATE = CURRENT_DATE();

-- 1.2 - Comparaison aujourd'hui vs hier
WITH today AS (
    SELECT
        COUNT(*) AS orders,
        SUM(TOTAL_AMOUNT) AS revenue
    FROM ORDERS
    WHERE ORDER_DATE = CURRENT_DATE()
),
yesterday AS (
    SELECT
        COUNT(*) AS orders,
        SUM(TOTAL_AMOUNT) AS revenue
    FROM ORDERS
    WHERE ORDER_DATE = DATEADD('day', -1, CURRENT_DATE())
)
SELECT
    t.orders AS orders_today,
    y.orders AS orders_yesterday,
    ROUND(((t.orders - y.orders) / y.orders) * 100, 2) AS orders_growth_pct,
    t.revenue AS revenue_today,
    y.revenue AS revenue_yesterday,
    ROUND(((t.revenue - y.revenue) / y.revenue) * 100, 2) AS revenue_growth_pct
FROM today t, yesterday y;

-- 1.3 - √âtat de l'inventaire (snapshot actuel)
SELECT
    PRODUCT_CATEGORY,
    COUNT(DISTINCT PRODUCT_ID) AS PRODUCT_COUNT,
    SUM(CURRENT_STOCK_LEVEL) AS TOTAL_STOCK,
    AVG(CURRENT_STOCK_LEVEL) AS AVG_STOCK_PER_PRODUCT,
    MIN(CURRENT_STOCK_LEVEL) AS MIN_STOCK,
    MAX(CURRENT_STOCK_LEVEL) AS MAX_STOCK
FROM INVENTORY_CURRENT
GROUP BY PRODUCT_CATEGORY
ORDER BY TOTAL_STOCK DESC;

-- ============================================
-- üèÜ SECTION 2: TOP PERFORMERS
-- ============================================

-- 2.1 - Top 10 produits par revenus (dernier mois)
SELECT
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(QUANTITY) AS UNITS_SOLD,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE,
    AVG(UNIT_PRICE) AS AVG_PRICE
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY PRODUCT_NAME, PRODUCT_CATEGORY
ORDER BY TOTAL_REVENUE DESC
LIMIT 10;

-- 2.2 - Top 10 produits par volume (quantit√© vendue)
SELECT
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    SUM(QUANTITY) AS TOTAL_UNITS_SOLD,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY PRODUCT_NAME, PRODUCT_CATEGORY
ORDER BY TOTAL_UNITS_SOLD DESC
LIMIT 10;

-- 2.3 - Top cat√©gories de produits
SELECT
    PRODUCT_CATEGORY,
    COUNT(DISTINCT PRODUCT_ID) AS UNIQUE_PRODUCTS,
    COUNT(DISTINCT ORDER_ID) AS TOTAL_ORDERS,
    SUM(QUANTITY) AS TOTAL_UNITS,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE,
    AVG(UNIT_PRICE) AS AVG_UNIT_PRICE,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY PRODUCT_CATEGORY
ORDER BY TOTAL_REVENUE DESC;

-- 2.4 - Top 20 clients (par valeur)
SELECT
    CUSTOMER_ID,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(TOTAL_AMOUNT) AS LIFETIME_VALUE,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE,
    MIN(ORDER_DATE) AS FIRST_ORDER,
    MAX(ORDER_DATE) AS LAST_ORDER,
    DATEDIFF('day', MIN(ORDER_DATE), MAX(ORDER_DATE)) AS CUSTOMER_TENURE_DAYS,
    DATEDIFF('day', MAX(ORDER_DATE), CURRENT_DATE()) AS DAYS_SINCE_LAST_ORDER
FROM ORDERS
GROUP BY CUSTOMER_ID
ORDER BY LIFETIME_VALUE DESC
LIMIT 20;

-- ============================================
-- üìà SECTION 3: TENDANCES ET √âVOLUTION
-- ============================================

-- 3.1 - √âvolution des ventes par jour (30 derniers jours)
SELECT
    ORDER_DATE,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    COUNT(DISTINCT CUSTOMER_ID) AS CUSTOMER_COUNT,
    SUM(TOTAL_AMOUNT) AS DAILY_REVENUE,
    SUM(QUANTITY) AS UNITS_SOLD,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY ORDER_DATE
ORDER BY ORDER_DATE DESC;

-- 3.2 - Tendance par cat√©gorie (semaine par semaine)
SELECT
    DATE_TRUNC('week', ORDER_DATE) AS WEEK_START,
    PRODUCT_CATEGORY,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(TOTAL_AMOUNT) AS WEEKLY_REVENUE,
    SUM(QUANTITY) AS UNITS_SOLD
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -90, CURRENT_DATE())
GROUP BY DATE_TRUNC('week', ORDER_DATE), PRODUCT_CATEGORY
ORDER BY WEEK_START DESC, WEEKLY_REVENUE DESC;

-- 3.3 - Analyse de saisonnalit√© (jour de la semaine)
SELECT
    DAYNAME(ORDER_DATE) AS DAY_OF_WEEK,
    DAYOFWEEK(ORDER_DATE) AS DAY_NUMBER,
    COUNT(DISTINCT ORDER_ID) AS AVG_ORDERS,
    SUM(TOTAL_AMOUNT) AS AVG_REVENUE,
    SUM(QUANTITY) AS AVG_UNITS
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -90, CURRENT_DATE())
GROUP BY DAYNAME(ORDER_DATE), DAYOFWEEK(ORDER_DATE)
ORDER BY DAY_NUMBER;

-- 3.4 - Analyse horaire (heures de pointe)
SELECT
    HOUR(ORDER_TIMESTAMP) AS HOUR_OF_DAY,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(TOTAL_AMOUNT) AS REVENUE,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY HOUR(ORDER_TIMESTAMP)
ORDER BY HOUR_OF_DAY;

-- ============================================
-- üîç SECTION 4: ANALYSE DES CLIENTS
-- ============================================

-- 4.1 - Segmentation RFM (Recency, Frequency, Monetary)
WITH customer_metrics AS (
    SELECT
        CUSTOMER_ID,
        DATEDIFF('day', MAX(ORDER_DATE), CURRENT_DATE()) AS RECENCY_DAYS,
        COUNT(DISTINCT ORDER_ID) AS FREQUENCY,
        SUM(TOTAL_AMOUNT) AS MONETARY
    FROM ORDERS
    GROUP BY CUSTOMER_ID
),
rfm_scores AS (
    SELECT
        CUSTOMER_ID,
        RECENCY_DAYS,
        FREQUENCY,
        MONETARY,
        NTILE(5) OVER (ORDER BY RECENCY_DAYS DESC) AS R_SCORE,
        NTILE(5) OVER (ORDER BY FREQUENCY ASC) AS F_SCORE,
        NTILE(5) OVER (ORDER BY MONETARY ASC) AS M_SCORE
    FROM customer_metrics
)
SELECT
    CUSTOMER_ID,
    RECENCY_DAYS,
    FREQUENCY,
    ROUND(MONETARY, 2) AS LIFETIME_VALUE,
    R_SCORE,
    F_SCORE,
    M_SCORE,
    (R_SCORE + F_SCORE + M_SCORE) AS RFM_TOTAL,
    CASE
        WHEN R_SCORE >= 4 AND F_SCORE >= 4 AND M_SCORE >= 4 THEN 'üåü Champions'
        WHEN R_SCORE >= 3 AND F_SCORE >= 3 THEN 'üíé Loyal Customers'
        WHEN R_SCORE >= 4 THEN 'üî• Recent Customers'
        WHEN F_SCORE >= 4 THEN '‚≠ê Frequent Buyers'
        WHEN M_SCORE >= 4 THEN 'üí∞ High Spenders'
        WHEN R_SCORE <= 2 THEN '‚ö†Ô∏è  At Risk'
        ELSE 'üìä Regular'
    END AS CUSTOMER_SEGMENT
FROM rfm_scores
ORDER BY RFM_TOTAL DESC, MONETARY DESC;

-- 4.2 - Clients fid√®les (5+ commandes, derniers 90 jours)
SELECT
    CUSTOMER_ID,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(TOTAL_AMOUNT) AS LIFETIME_VALUE,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE,
    MIN(ORDER_DATE) AS FIRST_ORDER,
    MAX(ORDER_DATE) AS LAST_ORDER,
    DATEDIFF('day', MIN(ORDER_DATE), MAX(ORDER_DATE)) AS TENURE_DAYS,
    ROUND(SUM(TOTAL_AMOUNT) / COUNT(DISTINCT ORDER_ID), 2) AS ORDER_VALUE,
    ROUND(COUNT(DISTINCT ORDER_ID) / 
          (DATEDIFF('day', MIN(ORDER_DATE), MAX(ORDER_DATE)) + 1) * 30, 2) AS ORDERS_PER_MONTH
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -90, CURRENT_DATE())
GROUP BY CUSTOMER_ID
HAVING ORDER_COUNT >= 5
ORDER BY LIFETIME_VALUE DESC;

-- 4.3 - Clients inactifs (pas de commande depuis 30+ jours)
SELECT
    CUSTOMER_ID,
    MAX(ORDER_DATE) AS LAST_ORDER_DATE,
    DATEDIFF('day', MAX(ORDER_DATE), CURRENT_DATE()) AS DAYS_INACTIVE,
    COUNT(DISTINCT ORDER_ID) AS TOTAL_ORDERS,
    SUM(TOTAL_AMOUNT) AS LIFETIME_VALUE,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE
FROM ORDERS
GROUP BY CUSTOMER_ID
HAVING DAYS_INACTIVE >= 30
ORDER BY LIFETIME_VALUE DESC, DAYS_INACTIVE DESC;

-- ============================================
-- üì¶ SECTION 5: GESTION D'INVENTAIRE
-- ============================================

-- 5.1 - Alertes de stock bas (< 50 unit√©s)
SELECT
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    CURRENT_STOCK_LEVEL,
    WAREHOUSE_LOCATION,
    LAST_ADJUSTMENT_TIMESTAMP,
    DATEDIFF('hour', LAST_ADJUSTMENT_TIMESTAMP, CURRENT_TIMESTAMP()) AS HOURS_SINCE_LAST_UPDATE,
    CASE
        WHEN CURRENT_STOCK_LEVEL = 0 THEN 'üî¥ RUPTURE'
        WHEN CURRENT_STOCK_LEVEL < 20 THEN 'üü† CRITIQUE'
        WHEN CURRENT_STOCK_LEVEL < 50 THEN 'üü° BAS'
        ELSE 'üü¢ OK'
    END AS STOCK_STATUS
FROM INVENTORY_CURRENT
WHERE CURRENT_STOCK_LEVEL < 50
ORDER BY CURRENT_STOCK_LEVEL ASC;

-- 5.2 - Pr√©vision de rupture de stock (bas√©e sur ventes moyennes)
WITH daily_sales AS (
    SELECT
        PRODUCT_ID,
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        ORDER_DATE,
        SUM(QUANTITY) AS DAILY_QUANTITY
    FROM ORDERS
    WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
    GROUP BY PRODUCT_ID, PRODUCT_NAME, PRODUCT_CATEGORY, ORDER_DATE
),
avg_sales AS (
    SELECT
        PRODUCT_ID,
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        AVG(DAILY_QUANTITY) AS AVG_DAILY_SALES,
        STDDEV(DAILY_QUANTITY) AS STDDEV_DAILY_SALES
    FROM daily_sales
    GROUP BY PRODUCT_ID, PRODUCT_NAME, PRODUCT_CATEGORY
)
SELECT
    i.PRODUCT_ID,
    i.PRODUCT_NAME,
    i.PRODUCT_CATEGORY,
    i.CURRENT_STOCK_LEVEL,
    ROUND(s.AVG_DAILY_SALES, 2) AS AVG_DAILY_SALES,
    ROUND(s.STDDEV_DAILY_SALES, 2) AS SALES_VOLATILITY,
    CASE
        WHEN s.AVG_DAILY_SALES > 0 THEN
            ROUND(i.CURRENT_STOCK_LEVEL / s.AVG_DAILY_SALES, 1)
        ELSE NULL
    END AS DAYS_OF_STOCK,
    CASE
        WHEN i.CURRENT_STOCK_LEVEL = 0 THEN 'üî¥ RUPTURE STOCK'
        WHEN i.CURRENT_STOCK_LEVEL / s.AVG_DAILY_SALES < 3 THEN 'üî¥ URGENT (< 3 jours)'
        WHEN i.CURRENT_STOCK_LEVEL / s.AVG_DAILY_SALES < 7 THEN 'üü† ATTENTION (< 7 jours)'
        WHEN i.CURRENT_STOCK_LEVEL / s.AVG_DAILY_SALES < 14 THEN 'üü° SURVEILLER (< 14 jours)'
        ELSE 'üü¢ OK'
    END AS STOCK_ALERT,
    i.WAREHOUSE_LOCATION,
    i.LAST_ADJUSTMENT_TIMESTAMP
FROM INVENTORY_CURRENT i
JOIN avg_sales s ON i.PRODUCT_ID = s.PRODUCT_ID
WHERE s.AVG_DAILY_SALES > 0
ORDER BY DAYS_OF_STOCK ASC NULLS FIRST;

-- 5.3 - Historique des ajustements d'inventaire (derniers 7 jours)
SELECT
    ADJUSTMENT_DATE,
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    ADJUSTMENT_TYPE,
    QUANTITY_CHANGE,
    NEW_STOCK_LEVEL,
    REASON,
    WAREHOUSE_LOCATION
FROM INVENTORY_HISTORY
WHERE ADJUSTMENT_DATE >= DATEADD('day', -7, CURRENT_DATE())
ORDER BY ADJUSTMENT_TIMESTAMP DESC;

-- 5.4 - Analyse des ajustements par type
SELECT
    ADJUSTMENT_TYPE,
    COUNT(*) AS ADJUSTMENT_COUNT,
    SUM(ABS(QUANTITY_CHANGE)) AS TOTAL_QUANTITY_MOVED,
    AVG(ABS(QUANTITY_CHANGE)) AS AVG_ADJUSTMENT_SIZE,
    COUNT(DISTINCT PRODUCT_ID) AS PRODUCTS_AFFECTED
FROM INVENTORY_HISTORY
WHERE ADJUSTMENT_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY ADJUSTMENT_TYPE
ORDER BY ADJUSTMENT_COUNT DESC;

-- 5.5 - Rotation des stocks (turnover rate)
WITH sales_30d AS (
    SELECT
        PRODUCT_ID,
        SUM(QUANTITY) AS UNITS_SOLD
    FROM ORDERS
    WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
    GROUP BY PRODUCT_ID
)
SELECT
    i.PRODUCT_ID,
    i.PRODUCT_NAME,
    i.PRODUCT_CATEGORY,
    i.CURRENT_STOCK_LEVEL,
    COALESCE(s.UNITS_SOLD, 0) AS UNITS_SOLD_30D,
    CASE
        WHEN i.CURRENT_STOCK_LEVEL > 0 THEN
            ROUND((COALESCE(s.UNITS_SOLD, 0) / i.CURRENT_STOCK_LEVEL) * 100, 2)
        ELSE NULL
    END AS TURNOVER_RATE_PCT,
    CASE
        WHEN COALESCE(s.UNITS_SOLD, 0) = 0 AND i.CURRENT_STOCK_LEVEL > 50 THEN '‚ùå Stock mort (pas de vente)'
        WHEN (s.UNITS_SOLD / i.CURRENT_STOCK_LEVEL) < 0.1 THEN 'üêå Rotation lente'
        WHEN (s.UNITS_SOLD / i.CURRENT_STOCK_LEVEL) < 0.5 THEN 'üö∂ Rotation normale'
        WHEN (s.UNITS_SOLD / i.CURRENT_STOCK_LEVEL) < 1.0 THEN 'üèÉ Rotation rapide'
        ELSE 'üöÄ Rotation tr√®s rapide'
    END AS TURNOVER_STATUS
FROM INVENTORY_CURRENT i
LEFT JOIN sales_30d s ON i.PRODUCT_ID = s.PRODUCT_ID
ORDER BY TURNOVER_RATE_PCT DESC NULLS LAST;

-- ============================================
-- üí∞ SECTION 6: ANALYSE FINANCI√àRE
-- ============================================

-- 6.1 - Revenus par mode de paiement
SELECT
    PAYMENT_METHOD,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE,
    ROUND((SUM(TOTAL_AMOUNT) / (SELECT SUM(TOTAL_AMOUNT) FROM ORDERS)) * 100, 2) AS REVENUE_PCT
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY PAYMENT_METHOD
ORDER BY TOTAL_REVENUE DESC;

-- 6.2 - Panier moyen par cat√©gorie
SELECT
    PRODUCT_CATEGORY,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE,
    AVG(TOTAL_AMOUNT) AS AVG_BASKET_SIZE,
    AVG(QUANTITY) AS AVG_QUANTITY_PER_ORDER,
    AVG(UNIT_PRICE) AS AVG_UNIT_PRICE
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY PRODUCT_CATEGORY
ORDER BY AVG_BASKET_SIZE DESC;

-- 6.3 - √âvolution mensuelle (MoM - Month over Month)
WITH monthly_sales AS (
    SELECT
        DATE_TRUNC('month', ORDER_DATE) AS MONTH,
        COUNT(DISTINCT ORDER_ID) AS ORDERS,
        SUM(TOTAL_AMOUNT) AS REVENUE
    FROM ORDERS
    WHERE ORDER_DATE >= DATEADD('month', -6, CURRENT_DATE())
    GROUP BY DATE_TRUNC('month', ORDER_DATE)
)
SELECT
    MONTH,
    ORDERS,
    REVENUE,
    LAG(ORDERS, 1) OVER (ORDER BY MONTH) AS PREV_MONTH_ORDERS,
    LAG(REVENUE, 1) OVER (ORDER BY MONTH) AS PREV_MONTH_REVENUE,
    ROUND(((ORDERS - LAG(ORDERS, 1) OVER (ORDER BY MONTH)) / 
           LAG(ORDERS, 1) OVER (ORDER BY MONTH)) * 100, 2) AS ORDERS_GROWTH_PCT,
    ROUND(((REVENUE - LAG(REVENUE, 1) OVER (ORDER BY MONTH)) / 
           LAG(REVENUE, 1) OVER (ORDER BY MONTH)) * 100, 2) AS REVENUE_GROWTH_PCT
FROM monthly_sales
ORDER BY MONTH DESC;

-- ============================================
-- üéØ SECTION 7: ANALYSE DE PERFORMANCE PRODUIT
-- ============================================

-- 7.1 - Produits les plus rentables
SELECT
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    SUM(QUANTITY) AS UNITS_SOLD,
    AVG(UNIT_PRICE) AS AVG_PRICE,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE,
    ROUND(SUM(TOTAL_AMOUNT) / SUM(QUANTITY), 2) AS REVENUE_PER_UNIT
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY PRODUCT_NAME, PRODUCT_CATEGORY
HAVING UNITS_SOLD >= 5
ORDER BY TOTAL_REVENUE DESC
LIMIT 20;

-- 7.2 - Analyse ABC (80/20 rule - Pareto)
WITH product_revenue AS (
    SELECT
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        SUM(TOTAL_AMOUNT) AS REVENUE
    FROM ORDERS
    WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
    GROUP BY PRODUCT_NAME, PRODUCT_CATEGORY
),
cumulative AS (
    SELECT
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        REVENUE,
        SUM(REVENUE) OVER (ORDER BY REVENUE DESC) AS CUMULATIVE_REVENUE,
        SUM(REVENUE) OVER () AS TOTAL_REVENUE
    FROM product_revenue
)
SELECT
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    REVENUE,
    ROUND((CUMULATIVE_REVENUE / TOTAL_REVENUE) * 100, 2) AS CUMULATIVE_PCT,
    CASE
        WHEN (CUMULATIVE_REVENUE / TOTAL_REVENUE) <= 0.80 THEN 'A - Top 80%'
        WHEN (CUMULATIVE_REVENUE / TOTAL_REVENUE) <= 0.95 THEN 'B - Next 15%'
        ELSE 'C - Bottom 5%'
    END AS ABC_CLASS
FROM cumulative
ORDER BY REVENUE DESC;

-- 7.3 - Produits en d√©clin (baisse de ventes vs p√©riode pr√©c√©dente)
WITH current_period AS (
    SELECT
        PRODUCT_ID,
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        SUM(QUANTITY) AS CURRENT_SALES
    FROM ORDERS
    WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
    GROUP BY PRODUCT_ID, PRODUCT_NAME, PRODUCT_CATEGORY
),
previous_period AS (
    SELECT
        PRODUCT_ID,
        SUM(QUANTITY) AS PREVIOUS_SALES
    FROM ORDERS
    WHERE ORDER_DATE >= DATEADD('day', -60, CURRENT_DATE())
        AND ORDER_DATE < DATEADD('day', -30, CURRENT_DATE())
    GROUP BY PRODUCT_ID
)
SELECT
    c.PRODUCT_NAME,
    c.PRODUCT_CATEGORY,
    p.PREVIOUS_SALES,
    c.CURRENT_SALES,
    (c.CURRENT_SALES - p.PREVIOUS_SALES) AS SALES_CHANGE,
    ROUND(((c.CURRENT_SALES - p.PREVIOUS_SALES) / p.PREVIOUS_SALES) * 100, 2) AS CHANGE_PCT
FROM current_period c
JOIN previous_period p ON c.PRODUCT_ID = p.PRODUCT_ID
WHERE p.PREVIOUS_SALES > 0
    AND ((c.CURRENT_SALES - p.PREVIOUS_SALES) / p.PREVIOUS_SALES) < -0.20  -- Baisse > 20%
ORDER BY CHANGE_PCT ASC;

-- ============================================
-- üîî SECTION 8: ALERTES ET MONITORING
-- ============================================

-- 8.1 - Vue d'ensemble des alertes
SELECT
    'Stock critique (< 20 unit√©s)' AS ALERT_TYPE,
    COUNT(*) AS ALERT_COUNT,
    'üî¥ URGENT' AS PRIORITY
FROM INVENTORY_CURRENT
WHERE CURRENT_STOCK_LEVEL < 20

UNION ALL

SELECT
    'Stock bas (20-50 unit√©s)',
    COUNT(*),
    'üü† IMPORTANT'
FROM INVENTORY_CURRENT
WHERE CURRENT_STOCK_LEVEL BETWEEN 20 AND 50

UNION ALL

SELECT
    'Clients inactifs (30+ jours)',
    COUNT(DISTINCT CUSTOMER_ID),
    'üü° MOYEN'
FROM ORDERS
GROUP BY CUSTOMER_ID
HAVING DATEDIFF('day', MAX(ORDER_DATE), CURRENT_DATE()) >= 30

UNION ALL

SELECT
    'Produits sans vente (7 derniers jours)',
    COUNT(DISTINCT i.PRODUCT_ID),
    'üü¢ INFO'
FROM INVENTORY_CURRENT i
LEFT JOIN ORDERS o ON i.PRODUCT_ID = o.PRODUCT_ID
    AND o.ORDER_DATE >= DATEADD('day', -7, CURRENT_DATE())
WHERE o.PRODUCT_ID IS NULL;

-- 8.2 - Rapport de sant√© du pipeline
SELECT
    'RAW_EVENTS_STREAM' AS LAYER,
    COUNT(*) AS ROW_COUNT,
    MAX(INGESTION_TIMESTAMP) AS LAST_UPDATE,
    DATEDIFF('minute', MAX(INGESTION_TIMESTAMP), CURRENT_TIMESTAMP()) AS MINUTES_SINCE_LAST_UPDATE
FROM RAW_DATA.RAW_EVENTS_STREAM

UNION ALL

SELECT
    'ORDERS (PRODUCTION)',
    COUNT(*),
    MAX(UPDATED_AT),
    DATEDIFF('minute', MAX(UPDATED_AT), CURRENT_TIMESTAMP())
FROM ORDERS

UNION ALL

SELECT
    'INVENTORY_CURRENT',
    COUNT(*),
    MAX(UPDATED_AT),
    DATEDIFF('minute', MAX(UPDATED_AT), CURRENT_TIMESTAMP())
FROM INVENTORY_CURRENT;

-- ============================================
-- üìä SECTION 9: VUES MAT√âRIALIS√âES (RECOMMAND√â)
-- ============================================

-- Cr√©er des vues pour acc√©l√©rer les dashboards

-- Vue 1: KPI quotidiens
CREATE OR REPLACE VIEW VW_DAILY_KPI AS
SELECT
    ORDER_DATE,
    COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT,
    COUNT(DISTINCT CUSTOMER_ID) AS CUSTOMER_COUNT,
    SUM(TOTAL_AMOUNT) AS DAILY_REVENUE,
    AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE,
    SUM(QUANTITY) AS UNITS_SOLD
FROM ORDERS
GROUP BY ORDER_DATE;

-- Vue 2: Performance par produit
CREATE OR REPLACE VIEW VW_PRODUCT_PERFORMANCE AS
SELECT
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    COUNT(DISTINCT ORDER_ID) AS TOTAL_ORDERS,
    SUM(QUANTITY) AS TOTAL_UNITS_SOLD,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE,
    AVG(UNIT_PRICE) AS AVG_PRICE,
    MAX(ORDER_DATE) AS LAST_SALE_DATE
FROM ORDERS
GROUP BY PRODUCT_ID, PRODUCT_NAME, PRODUCT_CATEGORY;

-- Vue 3: Snapshot de l'inventaire avec alertes
CREATE OR REPLACE VIEW VW_INVENTORY_ALERTS AS
SELECT
    i.PRODUCT_ID,
    i.PRODUCT_NAME,
    i.PRODUCT_CATEGORY,
    i.CURRENT_STOCK_LEVEL,
    i.WAREHOUSE_LOCATION,
    i.LAST_ADJUSTMENT_TIMESTAMP,
    CASE
        WHEN i.CURRENT_STOCK_LEVEL = 0 THEN 'üî¥ RUPTURE'
        WHEN i.CURRENT_STOCK_LEVEL < 20 THEN 'üü† CRITIQUE'
        WHEN i.CURRENT_STOCK_LEVEL < 50 THEN 'üü° BAS'
        ELSE 'üü¢ OK'
    END AS STOCK_STATUS,
    COALESCE(s.UNITS_SOLD_30D, 0) AS SALES_LAST_30_DAYS
FROM INVENTORY_CURRENT i
LEFT JOIN (
    SELECT PRODUCT_ID, SUM(QUANTITY) AS UNITS_SOLD_30D
    FROM ORDERS
    WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
    GROUP BY PRODUCT_ID
) s ON i.PRODUCT_ID = s.PRODUCT_ID;

-- ============================================
-- üéì SECTION 10: EXEMPLES D'USAGE
-- ============================================

-- Exemple 1: Dashboard manager (vue d'ensemble)
SELECT * FROM VW_DAILY_KPI
WHERE ORDER_DATE >= DATEADD('day', -7, CURRENT_DATE())
ORDER BY ORDER_DATE DESC;

-- Exemple 2: Rapport de vente hebdomadaire
SELECT
    DATE_TRUNC('week', ORDER_DATE) AS WEEK,
    PRODUCT_CATEGORY,
    SUM(TOTAL_AMOUNT) AS WEEKLY_REVENUE
FROM ORDERS
WHERE ORDER_DATE >= DATEADD('week', -4, CURRENT_DATE())
GROUP BY 1, 2
ORDER BY 1 DESC, 3 DESC;

-- Exemple 3: Liste de commandes √† pr√©parer (aujourd'hui)
SELECT
    ORDER_ID,
    ORDER_TIMESTAMP,
    CUSTOMER_ID,
    PRODUCT_NAME,
    QUANTITY,
    TOTAL_AMOUNT,
    SHIPPING_ADDRESS,
    PAYMENT_METHOD
FROM ORDERS
WHERE ORDER_DATE = CURRENT_DATE()
ORDER BY ORDER_TIMESTAMP DESC;

-- ============================================
-- FIN DES REQU√äTES ANALYTIQUES
-- ============================================
-- Pour toute question ou personnalisation :
-- üìß Contact : data-team@lescavesdalbert.com
-- üìö Documentation : SNOWFLAKE_AUTOMATION_GUIDE.md
