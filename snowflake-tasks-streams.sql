-- ============================================
-- ðŸ· LES CAVES D'ALBERT - SNOWFLAKE TASKS & STREAMS
-- ============================================
-- Architecture: RAW â†’ STAGING â†’ PRODUCTION
-- Traitement automatisÃ© avec CDC (Change Data Capture)

USE DATABASE CAVES_ALBERT_DB;
USE SCHEMA RAW_DATA;

-- ============================================
-- 1ï¸âƒ£ CRÃ‰ATION DES TABLES DE STAGING ET PRODUCTION
-- ============================================

-- Table de staging pour les commandes
CREATE TABLE IF NOT EXISTS STAGING.STG_ORDERS (
    ORDER_ID VARCHAR(50),
    EVENT_TYPE VARCHAR(50),
    EVENT_TIMESTAMP TIMESTAMP_NTZ,
    CUSTOMER_ID VARCHAR(50),
    PRODUCT_ID VARCHAR(50),
    PRODUCT_NAME VARCHAR(200),
    PRODUCT_CATEGORY VARCHAR(50),
    QUANTITY NUMBER(10,0),
    UNIT_PRICE NUMBER(10,2),
    TOTAL_AMOUNT NUMBER(10,2),
    PAYMENT_METHOD VARCHAR(50),
    SHIPPING_ADDRESS VARCHAR(500),
    INGESTION_TIMESTAMP TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- Table de staging pour les ajustements d'inventaire
CREATE TABLE IF NOT EXISTS STAGING.STG_INVENTORY_ADJUSTMENTS (
    ADJUSTMENT_ID VARCHAR(50),
    EVENT_TYPE VARCHAR(50),
    EVENT_TIMESTAMP TIMESTAMP_NTZ,
    PRODUCT_ID VARCHAR(50),
    PRODUCT_NAME VARCHAR(200),
    PRODUCT_CATEGORY VARCHAR(50),
    ADJUSTMENT_TYPE VARCHAR(50),
    QUANTITY_CHANGE NUMBER(10,0),
    NEW_STOCK_LEVEL NUMBER(10,0),
    REASON VARCHAR(200),
    WAREHOUSE_LOCATION VARCHAR(100),
    INGESTION_TIMESTAMP TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- Table de production pour les commandes
CREATE TABLE IF NOT EXISTS PRODUCTION.ORDERS (
    ORDER_ID VARCHAR(50) PRIMARY KEY,
    ORDER_DATE DATE,
    ORDER_TIMESTAMP TIMESTAMP_NTZ,
    CUSTOMER_ID VARCHAR(50),
    PRODUCT_ID VARCHAR(50),
    PRODUCT_NAME VARCHAR(200),
    PRODUCT_CATEGORY VARCHAR(50),
    QUANTITY NUMBER(10,0),
    UNIT_PRICE NUMBER(10,2),
    TOTAL_AMOUNT NUMBER(10,2),
    PAYMENT_METHOD VARCHAR(50),
    SHIPPING_ADDRESS VARCHAR(500),
    CREATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    UPDATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- Table de production pour l'inventaire en temps rÃ©el
CREATE TABLE IF NOT EXISTS PRODUCTION.INVENTORY_CURRENT (
    PRODUCT_ID VARCHAR(50) PRIMARY KEY,
    PRODUCT_NAME VARCHAR(200),
    PRODUCT_CATEGORY VARCHAR(50),
    CURRENT_STOCK_LEVEL NUMBER(10,0),
    LAST_ADJUSTMENT_TIMESTAMP TIMESTAMP_NTZ,
    WAREHOUSE_LOCATION VARCHAR(100),
    UPDATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- Table de production pour l'historique des ajustements d'inventaire
CREATE TABLE IF NOT EXISTS PRODUCTION.INVENTORY_HISTORY (
    ADJUSTMENT_ID VARCHAR(50) PRIMARY KEY,
    ADJUSTMENT_DATE DATE,
    ADJUSTMENT_TIMESTAMP TIMESTAMP_NTZ,
    PRODUCT_ID VARCHAR(50),
    PRODUCT_NAME VARCHAR(200),
    PRODUCT_CATEGORY VARCHAR(50),
    ADJUSTMENT_TYPE VARCHAR(50),
    QUANTITY_CHANGE NUMBER(10,0),
    NEW_STOCK_LEVEL NUMBER(10,0),
    REASON VARCHAR(200),
    WAREHOUSE_LOCATION VARCHAR(100),
    CREATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- ============================================
-- 2ï¸âƒ£ CRÃ‰ATION DES STREAMS (CDC)
-- ============================================

-- Stream sur la table RAW pour dÃ©tecter les nouvelles commandes
CREATE OR REPLACE STREAM STREAM_RAW_ORDERS
ON TABLE RAW_EVENTS_STREAM
APPEND_ONLY = TRUE
COMMENT = 'ðŸ›’ Stream pour capturer les Ã©vÃ©nements ORDER_CREATED en temps rÃ©el';

-- Stream sur la table RAW pour dÃ©tecter les ajustements d'inventaire
CREATE OR REPLACE STREAM STREAM_RAW_INVENTORY
ON TABLE RAW_EVENTS_STREAM
APPEND_ONLY = TRUE
COMMENT = 'ðŸ“¦ Stream pour capturer les Ã©vÃ©nements INVENTORY_ADJUSTED en temps rÃ©el';

-- Stream sur la table de staging des commandes pour dÃ©tecter les changements
CREATE OR REPLACE STREAM STREAM_STG_ORDERS
ON TABLE STAGING.STG_ORDERS
COMMENT = 'ðŸ”„ Stream pour propager les commandes staging â†’ production';

-- Stream sur la table de staging des ajustements pour dÃ©tecter les changements
CREATE OR REPLACE STREAM STREAM_STG_INVENTORY
ON TABLE STAGING.STG_INVENTORY_ADJUSTMENTS
COMMENT = 'ðŸ”„ Stream pour propager les ajustements staging â†’ production';

-- ============================================
-- 3ï¸âƒ£ CRÃ‰ATION DES TASKS
-- ============================================

-- TASK 1: RAW â†’ STAGING (Commandes)
CREATE OR REPLACE TASK TASK_RAW_TO_STAGING_ORDERS
    WAREHOUSE = COMPUTE_WH
    SCHEDULE = '1 MINUTE'
    COMMENT = 'â±ï¸ Extrait les commandes de RAW vers STAGING toutes les 1 minute'
WHEN
    SYSTEM$STREAM_HAS_DATA('STREAM_RAW_ORDERS')
AS
INSERT INTO STAGING.STG_ORDERS (
    ORDER_ID,
    EVENT_TYPE,
    EVENT_TIMESTAMP,
    CUSTOMER_ID,
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    QUANTITY,
    UNIT_PRICE,
    TOTAL_AMOUNT,
    PAYMENT_METHOD,
    SHIPPING_ADDRESS
)
SELECT
    EVENT_DATA:order_id::VARCHAR AS ORDER_ID,
    EVENT_TYPE,
    EVENT_TIMESTAMP,
    EVENT_DATA:customer_id::VARCHAR AS CUSTOMER_ID,
    PRODUCT_ID,
    EVENT_DATA:product_name::VARCHAR AS PRODUCT_NAME,
    EVENT_DATA:product_category::VARCHAR AS PRODUCT_CATEGORY,
    EVENT_DATA:quantity::NUMBER AS QUANTITY,
    EVENT_DATA:unit_price::NUMBER AS UNIT_PRICE,
    EVENT_DATA:total_amount::NUMBER AS TOTAL_AMOUNT,
    EVENT_DATA:payment_method::VARCHAR AS PAYMENT_METHOD,
    EVENT_DATA:shipping_address::VARCHAR AS SHIPPING_ADDRESS
FROM STREAM_RAW_ORDERS
WHERE EVENT_TYPE = 'ORDER_CREATED'
    AND METADATA$ACTION = 'INSERT'
    AND METADATA$ISUPDATE = FALSE;

-- TASK 2: RAW â†’ STAGING (Inventaire)
CREATE OR REPLACE TASK TASK_RAW_TO_STAGING_INVENTORY
    WAREHOUSE = COMPUTE_WH
    SCHEDULE = '1 MINUTE'
    COMMENT = 'â±ï¸ Extrait les ajustements d''inventaire de RAW vers STAGING toutes les 1 minute'
WHEN
    SYSTEM$STREAM_HAS_DATA('STREAM_RAW_INVENTORY')
AS
INSERT INTO STAGING.STG_INVENTORY_ADJUSTMENTS (
    ADJUSTMENT_ID,
    EVENT_TYPE,
    EVENT_TIMESTAMP,
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    ADJUSTMENT_TYPE,
    QUANTITY_CHANGE,
    NEW_STOCK_LEVEL,
    REASON,
    WAREHOUSE_LOCATION
)
SELECT
    EVENT_DATA:adjustment_id::VARCHAR AS ADJUSTMENT_ID,
    EVENT_TYPE,
    EVENT_TIMESTAMP,
    PRODUCT_ID,
    EVENT_DATA:product_name::VARCHAR AS PRODUCT_NAME,
    EVENT_DATA:product_category::VARCHAR AS PRODUCT_CATEGORY,
    EVENT_DATA:adjustment_type::VARCHAR AS ADJUSTMENT_TYPE,
    EVENT_DATA:quantity_change::NUMBER AS QUANTITY_CHANGE,
    EVENT_DATA:new_stock_level::NUMBER AS NEW_STOCK_LEVEL,
    EVENT_DATA:reason::VARCHAR AS REASON,
    EVENT_DATA:warehouse_location::VARCHAR AS WAREHOUSE_LOCATION
FROM STREAM_RAW_INVENTORY
WHERE EVENT_TYPE = 'INVENTORY_ADJUSTED'
    AND METADATA$ACTION = 'INSERT'
    AND METADATA$ISUPDATE = FALSE;

-- TASK 3: STAGING â†’ PRODUCTION (Commandes)
-- ðŸš€ Charge les commandes de STAGING vers PRODUCTION (exÃ©cutÃ© aprÃ¨s TASK_RAW_TO_STAGING_ORDERS)
CREATE OR REPLACE TASK TASK_STAGING_TO_PROD_ORDERS
    WAREHOUSE = COMPUTE_WH
    AFTER TASK_RAW_TO_STAGING_ORDERS
WHEN
    SYSTEM$STREAM_HAS_DATA('STREAM_STG_ORDERS')
AS
MERGE INTO PRODUCTION.ORDERS AS target
USING (
    SELECT
        ORDER_ID,
        DATE(EVENT_TIMESTAMP) AS ORDER_DATE,
        EVENT_TIMESTAMP AS ORDER_TIMESTAMP,
        CUSTOMER_ID,
        PRODUCT_ID,
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        QUANTITY,
        UNIT_PRICE,
        TOTAL_AMOUNT,
        PAYMENT_METHOD,
        SHIPPING_ADDRESS,
        CURRENT_TIMESTAMP() AS UPDATED_AT
    FROM STREAM_STG_ORDERS
    WHERE METADATA$ACTION = 'INSERT'
        AND METADATA$ISUPDATE = FALSE
) AS source
ON target.ORDER_ID = source.ORDER_ID
WHEN MATCHED THEN
    UPDATE SET
        target.QUANTITY = source.QUANTITY,
        target.TOTAL_AMOUNT = source.TOTAL_AMOUNT,
        target.UPDATED_AT = source.UPDATED_AT
WHEN NOT MATCHED THEN
    INSERT (
        ORDER_ID,
        ORDER_DATE,
        ORDER_TIMESTAMP,
        CUSTOMER_ID,
        PRODUCT_ID,
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        QUANTITY,
        UNIT_PRICE,
        TOTAL_AMOUNT,
        PAYMENT_METHOD,
        SHIPPING_ADDRESS,
        UPDATED_AT
    )
    VALUES (
        source.ORDER_ID,
        source.ORDER_DATE,
        source.ORDER_TIMESTAMP,
        source.CUSTOMER_ID,
        source.PRODUCT_ID,
        source.PRODUCT_NAME,
        source.PRODUCT_CATEGORY,
        source.QUANTITY,
        source.UNIT_PRICE,
        source.TOTAL_AMOUNT,
        source.PAYMENT_METHOD,
        source.SHIPPING_ADDRESS,
        source.UPDATED_AT
    );

-- TASK 4: STAGING â†’ PRODUCTION (Inventaire - Historique)
-- ðŸ“š Charge l'historique des ajustements d'inventaire vers PRODUCTION
CREATE OR REPLACE TASK TASK_STAGING_TO_PROD_INVENTORY_HISTORY
    WAREHOUSE = COMPUTE_WH
    AFTER TASK_RAW_TO_STAGING_INVENTORY
WHEN
    SYSTEM$STREAM_HAS_DATA('STREAM_STG_INVENTORY')
AS
INSERT INTO PRODUCTION.INVENTORY_HISTORY (
    ADJUSTMENT_ID,
    ADJUSTMENT_DATE,
    ADJUSTMENT_TIMESTAMP,
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    ADJUSTMENT_TYPE,
    QUANTITY_CHANGE,
    NEW_STOCK_LEVEL,
    REASON,
    WAREHOUSE_LOCATION
)
SELECT
    ADJUSTMENT_ID,
    DATE(EVENT_TIMESTAMP) AS ADJUSTMENT_DATE,
    EVENT_TIMESTAMP AS ADJUSTMENT_TIMESTAMP,
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    ADJUSTMENT_TYPE,
    QUANTITY_CHANGE,
    NEW_STOCK_LEVEL,
    REASON,
    WAREHOUSE_LOCATION
FROM STREAM_STG_INVENTORY
WHERE METADATA$ACTION = 'INSERT'
    AND METADATA$ISUPDATE = FALSE;

-- TASK 5: STAGING â†’ PRODUCTION (Inventaire - Ã‰tat Actuel)
-- ðŸ“Š Met Ã  jour l'Ã©tat actuel de l'inventaire en temps rÃ©el
CREATE OR REPLACE TASK TASK_STAGING_TO_PROD_INVENTORY_CURRENT
    WAREHOUSE = COMPUTE_WH
    AFTER TASK_STAGING_TO_PROD_INVENTORY_HISTORY
WHEN
    SYSTEM$STREAM_HAS_DATA('STREAM_STG_INVENTORY')
AS
MERGE INTO PRODUCTION.INVENTORY_CURRENT AS target
USING (
    SELECT
        PRODUCT_ID,
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        NEW_STOCK_LEVEL,
        EVENT_TIMESTAMP AS LAST_ADJUSTMENT_TIMESTAMP,
        WAREHOUSE_LOCATION,
        CURRENT_TIMESTAMP() AS UPDATED_AT
    FROM STREAM_STG_INVENTORY
    WHERE METADATA$ACTION = 'INSERT'
        AND METADATA$ISUPDATE = FALSE
    QUALIFY ROW_NUMBER() OVER (PARTITION BY PRODUCT_ID ORDER BY EVENT_TIMESTAMP DESC) = 1
) AS source
ON target.PRODUCT_ID = source.PRODUCT_ID
WHEN MATCHED THEN
    UPDATE SET
        target.PRODUCT_NAME = source.PRODUCT_NAME,
        target.PRODUCT_CATEGORY = source.PRODUCT_CATEGORY,
        target.CURRENT_STOCK_LEVEL = source.NEW_STOCK_LEVEL,
        target.LAST_ADJUSTMENT_TIMESTAMP = source.LAST_ADJUSTMENT_TIMESTAMP,
        target.WAREHOUSE_LOCATION = source.WAREHOUSE_LOCATION,
        target.UPDATED_AT = source.UPDATED_AT
WHEN NOT MATCHED THEN
    INSERT (
        PRODUCT_ID,
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        CURRENT_STOCK_LEVEL,
        LAST_ADJUSTMENT_TIMESTAMP,
        WAREHOUSE_LOCATION,
        UPDATED_AT
    )
    VALUES (
        source.PRODUCT_ID,
        source.PRODUCT_NAME,
        source.PRODUCT_CATEGORY,
        source.NEW_STOCK_LEVEL,
        source.LAST_ADJUSTMENT_TIMESTAMP,
        source.WAREHOUSE_LOCATION,
        source.UPDATED_AT
    );

-- ============================================
-- 4ï¸âƒ£ ACTIVATION DES TASKS (DAG)
-- ============================================
-- Les tasks s'exÃ©cutent dans l'ordre suivant :
-- 1. TASK_RAW_TO_STAGING_ORDERS (toutes les 1 min)
--    â””â”€â”€ 2. TASK_STAGING_TO_PROD_ORDERS (aprÃ¨s task 1)
-- 3. TASK_RAW_TO_STAGING_INVENTORY (toutes les 1 min)
--    â””â”€â”€ 4. TASK_STAGING_TO_PROD_INVENTORY_HISTORY (aprÃ¨s task 3)
--        â””â”€â”€ 5. TASK_STAGING_TO_PROD_INVENTORY_CURRENT (aprÃ¨s task 4)

-- Activer les tasks enfants d'abord, puis les parents
ALTER TASK TASK_STAGING_TO_PROD_INVENTORY_CURRENT RESUME;
ALTER TASK TASK_STAGING_TO_PROD_INVENTORY_HISTORY RESUME;
ALTER TASK TASK_STAGING_TO_PROD_ORDERS RESUME;
ALTER TASK TASK_RAW_TO_STAGING_INVENTORY RESUME;
ALTER TASK TASK_RAW_TO_STAGING_ORDERS RESUME;

-- ============================================
-- 5ï¸âƒ£ MONITORING ET GESTION
-- ============================================

-- VÃ©rifier l'Ã©tat des tasks
SHOW TASKS IN SCHEMA RAW_DATA;

-- Voir l'historique d'exÃ©cution des tasks
SELECT
    NAME,
    STATE,
    SCHEDULED_TIME,
    COMPLETED_TIME,
    DATEDIFF('second', SCHEDULED_TIME, COMPLETED_TIME) AS DURATION_SECONDS,
    ERROR_CODE,
    ERROR_MESSAGE
FROM TABLE(INFORMATION_SCHEMA.TASK_HISTORY())
WHERE NAME IN (
    'TASK_RAW_TO_STAGING_ORDERS',
    'TASK_RAW_TO_STAGING_INVENTORY',
    'TASK_STAGING_TO_PROD_ORDERS',
    'TASK_STAGING_TO_PROD_INVENTORY_HISTORY',
    'TASK_STAGING_TO_PROD_INVENTORY_CURRENT'
)
ORDER BY SCHEDULED_TIME DESC
LIMIT 20;

-- VÃ©rifier si les streams ont des donnÃ©es en attente
SELECT 'STREAM_RAW_ORDERS' AS STREAM_NAME, SYSTEM$STREAM_HAS_DATA('STREAM_RAW_ORDERS') AS HAS_DATA
UNION ALL
SELECT 'STREAM_RAW_INVENTORY', SYSTEM$STREAM_HAS_DATA('STREAM_RAW_INVENTORY')
UNION ALL
SELECT 'STREAM_STG_ORDERS', SYSTEM$STREAM_HAS_DATA('STREAM_STG_ORDERS')
UNION ALL
SELECT 'STREAM_STG_INVENTORY', SYSTEM$STREAM_HAS_DATA('STREAM_STG_INVENTORY');

-- Voir le nombre de lignes dans chaque stream
SELECT 'STREAM_RAW_ORDERS' AS STREAM_NAME, COUNT(*) AS ROW_COUNT FROM STREAM_RAW_ORDERS
UNION ALL
SELECT 'STREAM_RAW_INVENTORY', COUNT(*) FROM STREAM_RAW_INVENTORY
UNION ALL
SELECT 'STREAM_STG_ORDERS', COUNT(*) FROM STREAM_STG_ORDERS
UNION ALL
SELECT 'STREAM_STG_INVENTORY', COUNT(*) FROM STREAM_STG_INVENTORY;

-- ============================================
-- 6ï¸âƒ£ COMMANDES DE GESTION
-- ============================================

-- Suspendre les tasks (dans l'ordre inverse)
-- ALTER TASK TASK_RAW_TO_STAGING_ORDERS SUSPEND;
-- ALTER TASK TASK_RAW_TO_STAGING_INVENTORY SUSPEND;
-- ALTER TASK TASK_STAGING_TO_PROD_ORDERS SUSPEND;
-- ALTER TASK TASK_STAGING_TO_PROD_INVENTORY_HISTORY SUSPEND;
-- ALTER TASK TASK_STAGING_TO_PROD_INVENTORY_CURRENT SUSPEND;

-- ExÃ©cuter manuellement une task (pour tester)
-- EXECUTE TASK TASK_RAW_TO_STAGING_ORDERS;

-- Supprimer les tasks (si besoin de tout recrÃ©er)
-- DROP TASK IF EXISTS TASK_STAGING_TO_PROD_INVENTORY_CURRENT;
-- DROP TASK IF EXISTS TASK_STAGING_TO_PROD_INVENTORY_HISTORY;
-- DROP TASK IF EXISTS TASK_STAGING_TO_PROD_ORDERS;
-- DROP TASK IF EXISTS TASK_RAW_TO_STAGING_INVENTORY;
-- DROP TASK IF EXISTS TASK_RAW_TO_STAGING_ORDERS;

-- Supprimer les streams
-- DROP STREAM IF EXISTS STREAM_STG_INVENTORY;
-- DROP STREAM IF EXISTS STREAM_STG_ORDERS;
-- DROP STREAM IF EXISTS STREAM_RAW_INVENTORY;
-- DROP STREAM IF EXISTS STREAM_RAW_ORDERS;

-- ============================================
-- 7ï¸âƒ£ REQUÃŠTES ANALYTIQUES
-- ============================================

-- Top 10 des produits les plus vendus
SELECT
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    COUNT(*) AS ORDER_COUNT,
    SUM(QUANTITY) AS TOTAL_QUANTITY,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE
FROM PRODUCTION.ORDERS
GROUP BY PRODUCT_NAME, PRODUCT_CATEGORY
ORDER BY TOTAL_REVENUE DESC
LIMIT 10;

-- Ã‰tat actuel de l'inventaire par catÃ©gorie
SELECT
    PRODUCT_CATEGORY,
    COUNT(DISTINCT PRODUCT_ID) AS PRODUCT_COUNT,
    SUM(CURRENT_STOCK_LEVEL) AS TOTAL_STOCK,
    AVG(CURRENT_STOCK_LEVEL) AS AVG_STOCK_PER_PRODUCT
FROM PRODUCTION.INVENTORY_CURRENT
GROUP BY PRODUCT_CATEGORY
ORDER BY TOTAL_STOCK DESC;

-- Tendance des ventes par jour (derniers 30 jours)
SELECT
    ORDER_DATE,
    COUNT(*) AS ORDER_COUNT,
    SUM(TOTAL_AMOUNT) AS DAILY_REVENUE
FROM PRODUCTION.ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY ORDER_DATE
ORDER BY ORDER_DATE DESC;

-- Alertes : Produits avec stock faible (< 50 unitÃ©s)
SELECT
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    CURRENT_STOCK_LEVEL,
    WAREHOUSE_LOCATION,
    LAST_ADJUSTMENT_TIMESTAMP
FROM PRODUCTION.INVENTORY_CURRENT
WHERE CURRENT_STOCK_LEVEL < 50
ORDER BY CURRENT_STOCK_LEVEL ASC;
