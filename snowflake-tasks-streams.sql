-- ============================================
-- üç∑ LES CAVES D'ALBERT - SNOWFLAKE TASKS & STREAMS
-- ============================================
-- Architecture: RAW ‚Üí STAGING ‚Üí PRODUCTION
-- Traitement automatis√© avec CDC (Change Data Capture)

USE DATABASE CAVES_ALBERT_DB;
USE SCHEMA RAW_DATA;

-- ============================================
-- 1Ô∏è‚É£ CR√âATION DES TABLES DE STAGING ET PRODUCTION
-- ============================================

-- Table de staging pour les commandes
CREATE TABLE IF NOT EXISTS STAGING.STG_ORDERS (
    ORDER_ID VARCHAR(50),
    EVENT_TYPE VARCHAR(50),
    EVENT_TIMESTAMP TIMESTAMP_NTZ,
    CUSTOMER_ID VARCHAR(50),
    PRODUCT_ID VARCHAR(50),
    PRODUCT_NAME VARCHAR(200),
    PRODUCT_CATEGORY VARCHAR(50),
    QUANTITY NUMBER(10,0),
    UNIT_PRICE NUMBER(10,2),
    TOTAL_AMOUNT NUMBER(10,2),
    PAYMENT_METHOD VARCHAR(50),
    SHIPPING_ADDRESS VARCHAR(500),
    INGESTION_TIMESTAMP TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- Table de staging pour les ajustements d'inventaire
CREATE TABLE IF NOT EXISTS STAGING.STG_INVENTORY_ADJUSTMENTS (
    ADJUSTMENT_ID VARCHAR(50),
    EVENT_TYPE VARCHAR(50),
    EVENT_TIMESTAMP TIMESTAMP_NTZ,
    PRODUCT_ID VARCHAR(50),
    PRODUCT_NAME VARCHAR(200),
    PRODUCT_CATEGORY VARCHAR(50),
    ADJUSTMENT_TYPE VARCHAR(50),
    QUANTITY_CHANGE NUMBER(10,0),
    NEW_STOCK_LEVEL NUMBER(10,0),
    REASON VARCHAR(200),
    WAREHOUSE_LOCATION VARCHAR(100),
    INGESTION_TIMESTAMP TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- Table de production pour les commandes
CREATE TABLE IF NOT EXISTS PRODUCTION.ORDERS (
    ORDER_ID VARCHAR(50) PRIMARY KEY,
    ORDER_DATE DATE,
    ORDER_TIMESTAMP TIMESTAMP_NTZ,
    CUSTOMER_ID VARCHAR(50),
    PRODUCT_ID VARCHAR(50),
    PRODUCT_NAME VARCHAR(200),
    PRODUCT_CATEGORY VARCHAR(50),
    QUANTITY NUMBER(10,0),
    UNIT_PRICE NUMBER(10,2),
    TOTAL_AMOUNT NUMBER(10,2),
    PAYMENT_METHOD VARCHAR(50),
    SHIPPING_ADDRESS VARCHAR(500),
    CREATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    UPDATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- Table de production pour l'inventaire en temps r√©el
CREATE TABLE IF NOT EXISTS PRODUCTION.INVENTORY_CURRENT (
    PRODUCT_ID VARCHAR(50) PRIMARY KEY,
    PRODUCT_NAME VARCHAR(200),
    PRODUCT_CATEGORY VARCHAR(50),
    CURRENT_STOCK_LEVEL NUMBER(10,0),
    LAST_ADJUSTMENT_TIMESTAMP TIMESTAMP_NTZ,
    WAREHOUSE_LOCATION VARCHAR(100),
    UPDATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- Table de production pour l'historique des ajustements d'inventaire
CREATE TABLE IF NOT EXISTS PRODUCTION.INVENTORY_HISTORY (
    ADJUSTMENT_ID VARCHAR(50) PRIMARY KEY,
    ADJUSTMENT_DATE DATE,
    ADJUSTMENT_TIMESTAMP TIMESTAMP_NTZ,
    PRODUCT_ID VARCHAR(50),
    PRODUCT_NAME VARCHAR(200),
    PRODUCT_CATEGORY VARCHAR(50),
    ADJUSTMENT_TYPE VARCHAR(50),
    QUANTITY_CHANGE NUMBER(10,0),
    NEW_STOCK_LEVEL NUMBER(10,0),
    REASON VARCHAR(200),
    WAREHOUSE_LOCATION VARCHAR(100),
    CREATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- ============================================
-- 2Ô∏è‚É£ CR√âATION DES STREAMS (CDC)
-- ============================================

-- Stream sur la table RAW pour d√©tecter les nouvelles commandes
CREATE OR REPLACE STREAM STREAM_RAW_ORDERS
ON TABLE RAW_EVENTS_STREAM
APPEND_ONLY = TRUE
COMMENT = 'üõí Stream pour capturer les √©v√©nements ORDER_CREATED en temps r√©el';

-- Stream sur la table RAW pour d√©tecter les ajustements d'inventaire
CREATE OR REPLACE STREAM STREAM_RAW_INVENTORY
ON TABLE RAW_EVENTS_STREAM
APPEND_ONLY = TRUE
COMMENT = 'üì¶ Stream pour capturer les √©v√©nements INVENTORY_ADJUSTED en temps r√©el';

-- Stream sur la table de staging des commandes pour d√©tecter les changements
CREATE OR REPLACE STREAM STREAM_STG_ORDERS
ON TABLE STAGING.STG_ORDERS
COMMENT = 'üîÑ Stream pour propager les commandes staging ‚Üí production';

-- Stream sur la table de staging des ajustements pour d√©tecter les changements
CREATE OR REPLACE STREAM STREAM_STG_INVENTORY
ON TABLE STAGING.STG_INVENTORY_ADJUSTMENTS
COMMENT = 'üîÑ Stream pour propager les ajustements staging ‚Üí production';

-- ============================================
-- 3Ô∏è‚É£ CR√âATION DES TASKS
-- ============================================

-- TASK 1: RAW ‚Üí STAGING (Commandes)
CREATE OR REPLACE TASK TASK_RAW_TO_STAGING_ORDERS
    WAREHOUSE = COMPUTE_WH
    SCHEDULE = '1 MINUTE'
    COMMENT = '‚è±Ô∏è Extrait les commandes de RAW vers STAGING toutes les 1 minute'
WHEN
    SYSTEM$STREAM_HAS_DATA('STREAM_RAW_ORDERS')
AS
INSERT INTO STAGING.STG_ORDERS (
    ORDER_ID,
    EVENT_TYPE,
    EVENT_TIMESTAMP,
    CUSTOMER_ID,
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    QUANTITY,
    UNIT_PRICE,
    TOTAL_AMOUNT,
    PAYMENT_METHOD,
    SHIPPING_ADDRESS
)
SELECT
    EVENT_DATA:order_id::VARCHAR AS ORDER_ID,
    EVENT_TYPE,
    EVENT_TIMESTAMP,
    EVENT_DATA:customer_id::VARCHAR AS CUSTOMER_ID,
    PRODUCT_ID,
    EVENT_DATA:product_name::VARCHAR AS PRODUCT_NAME,
    EVENT_DATA:product_category::VARCHAR AS PRODUCT_CATEGORY,
    EVENT_DATA:quantity::NUMBER AS QUANTITY,
    EVENT_DATA:unit_price::NUMBER AS UNIT_PRICE,
    EVENT_DATA:total_amount::NUMBER AS TOTAL_AMOUNT,
    EVENT_DATA:payment_method::VARCHAR AS PAYMENT_METHOD,
    EVENT_DATA:shipping_address::VARCHAR AS SHIPPING_ADDRESS
FROM STREAM_RAW_ORDERS
WHERE EVENT_TYPE = 'ORDER_CREATED'
    AND METADATA$ACTION = 'INSERT'
    AND METADATA$ISUPDATE = FALSE;

-- TASK 2: RAW ‚Üí STAGING (Inventaire)
CREATE OR REPLACE TASK TASK_RAW_TO_STAGING_INVENTORY
    WAREHOUSE = COMPUTE_WH
    SCHEDULE = '1 MINUTE'
    COMMENT = '‚è±Ô∏è Extrait les ajustements d''inventaire de RAW vers STAGING toutes les 1 minute'
WHEN
    SYSTEM$STREAM_HAS_DATA('STREAM_RAW_INVENTORY')
AS
INSERT INTO STAGING.STG_INVENTORY_ADJUSTMENTS (
    ADJUSTMENT_ID,
    EVENT_TYPE,
    EVENT_TIMESTAMP,
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    ADJUSTMENT_TYPE,
    QUANTITY_CHANGE,
    NEW_STOCK_LEVEL,
    REASON,
    WAREHOUSE_LOCATION
)
SELECT
    EVENT_DATA:adjustment_id::VARCHAR AS ADJUSTMENT_ID,
    EVENT_TYPE,
    EVENT_TIMESTAMP,
    PRODUCT_ID,
    EVENT_DATA:product_name::VARCHAR AS PRODUCT_NAME,
    EVENT_DATA:product_category::VARCHAR AS PRODUCT_CATEGORY,
    EVENT_DATA:adjustment_type::VARCHAR AS ADJUSTMENT_TYPE,
    EVENT_DATA:quantity_change::NUMBER AS QUANTITY_CHANGE,
    EVENT_DATA:new_stock_level::NUMBER AS NEW_STOCK_LEVEL,
    EVENT_DATA:reason::VARCHAR AS REASON,
    EVENT_DATA:warehouse_location::VARCHAR AS WAREHOUSE_LOCATION
FROM STREAM_RAW_INVENTORY
WHERE EVENT_TYPE = 'INVENTORY_ADJUSTED'
    AND METADATA$ACTION = 'INSERT'
    AND METADATA$ISUPDATE = FALSE;

-- TASK 3: STAGING ‚Üí PRODUCTION (Commandes)
-- üöÄ Charge les commandes de STAGING vers PRODUCTION (ex√©cut√© apr√®s TASK_RAW_TO_STAGING_ORDERS)
CREATE OR REPLACE TASK TASK_STAGING_TO_PROD_ORDERS
    WAREHOUSE = COMPUTE_WH
    AFTER TASK_RAW_TO_STAGING_ORDERS
WHEN
    SYSTEM$STREAM_HAS_DATA('STREAM_STG_ORDERS')
AS
MERGE INTO PRODUCTION.ORDERS AS target
USING (
    SELECT
        ORDER_ID,
        DATE(EVENT_TIMESTAMP) AS ORDER_DATE,
        EVENT_TIMESTAMP AS ORDER_TIMESTAMP,
        CUSTOMER_ID,
        PRODUCT_ID,
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        QUANTITY,
        UNIT_PRICE,
        TOTAL_AMOUNT,
        PAYMENT_METHOD,
        SHIPPING_ADDRESS,
        CURRENT_TIMESTAMP() AS UPDATED_AT
    FROM STREAM_STG_ORDERS
    WHERE METADATA$ACTION = 'INSERT'
        AND METADATA$ISUPDATE = FALSE
) AS source
ON target.ORDER_ID = source.ORDER_ID
WHEN MATCHED THEN
    UPDATE SET
        target.QUANTITY = source.QUANTITY,
        target.TOTAL_AMOUNT = source.TOTAL_AMOUNT,
        target.UPDATED_AT = source.UPDATED_AT
WHEN NOT MATCHED THEN
    INSERT (
        ORDER_ID,
        ORDER_DATE,
        ORDER_TIMESTAMP,
        CUSTOMER_ID,
        PRODUCT_ID,
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        QUANTITY,
        UNIT_PRICE,
        TOTAL_AMOUNT,
        PAYMENT_METHOD,
        SHIPPING_ADDRESS,
        UPDATED_AT
    )
    VALUES (
        source.ORDER_ID,
        source.ORDER_DATE,
        source.ORDER_TIMESTAMP,
        source.CUSTOMER_ID,
        source.PRODUCT_ID,
        source.PRODUCT_NAME,
        source.PRODUCT_CATEGORY,
        source.QUANTITY,
        source.UNIT_PRICE,
        source.TOTAL_AMOUNT,
        source.PAYMENT_METHOD,
        source.SHIPPING_ADDRESS,
        source.UPDATED_AT
    );

-- TASK 4: STAGING ‚Üí PRODUCTION (Inventaire - Historique)
-- üìö Charge l'historique des ajustements d'inventaire vers PRODUCTION
CREATE OR REPLACE TASK TASK_STAGING_TO_PROD_INVENTORY_HISTORY
    WAREHOUSE = COMPUTE_WH
    AFTER TASK_RAW_TO_STAGING_INVENTORY
WHEN
    SYSTEM$STREAM_HAS_DATA('STREAM_STG_INVENTORY')
AS
INSERT INTO PRODUCTION.INVENTORY_HISTORY (
    ADJUSTMENT_ID,
    ADJUSTMENT_DATE,
    ADJUSTMENT_TIMESTAMP,
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    ADJUSTMENT_TYPE,
    QUANTITY_CHANGE,
    NEW_STOCK_LEVEL,
    REASON,
    WAREHOUSE_LOCATION
)
SELECT
    ADJUSTMENT_ID,
    DATE(EVENT_TIMESTAMP) AS ADJUSTMENT_DATE,
    EVENT_TIMESTAMP AS ADJUSTMENT_TIMESTAMP,
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    ADJUSTMENT_TYPE,
    QUANTITY_CHANGE,
    NEW_STOCK_LEVEL,
    REASON,
    WAREHOUSE_LOCATION
FROM STREAM_STG_INVENTORY
WHERE METADATA$ACTION = 'INSERT'
    AND METADATA$ISUPDATE = FALSE;

-- TASK 5: STAGING ‚Üí PRODUCTION (Inventaire - √âtat Actuel)
-- üìä Met √† jour l'√©tat actuel de l'inventaire en temps r√©el
CREATE OR REPLACE TASK TASK_STAGING_TO_PROD_INVENTORY_CURRENT
    WAREHOUSE = COMPUTE_WH
    AFTER TASK_STAGING_TO_PROD_INVENTORY_HISTORY
WHEN
    SYSTEM$STREAM_HAS_DATA('STREAM_STG_INVENTORY')
AS
MERGE INTO PRODUCTION.INVENTORY_CURRENT AS target
USING (
    SELECT
        PRODUCT_ID,
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        NEW_STOCK_LEVEL,
        EVENT_TIMESTAMP AS LAST_ADJUSTMENT_TIMESTAMP,
        WAREHOUSE_LOCATION,
        CURRENT_TIMESTAMP() AS UPDATED_AT
    FROM STREAM_STG_INVENTORY
    WHERE METADATA$ACTION = 'INSERT'
        AND METADATA$ISUPDATE = FALSE
    QUALIFY ROW_NUMBER() OVER (PARTITION BY PRODUCT_ID ORDER BY EVENT_TIMESTAMP DESC) = 1
) AS source
ON target.PRODUCT_ID = source.PRODUCT_ID
WHEN MATCHED THEN
    UPDATE SET
        target.PRODUCT_NAME = source.PRODUCT_NAME,
        target.PRODUCT_CATEGORY = source.PRODUCT_CATEGORY,
        target.CURRENT_STOCK_LEVEL = source.NEW_STOCK_LEVEL,
        target.LAST_ADJUSTMENT_TIMESTAMP = source.LAST_ADJUSTMENT_TIMESTAMP,
        target.WAREHOUSE_LOCATION = source.WAREHOUSE_LOCATION,
        target.UPDATED_AT = source.UPDATED_AT
WHEN NOT MATCHED THEN
    INSERT (
        PRODUCT_ID,
        PRODUCT_NAME,
        PRODUCT_CATEGORY,
        CURRENT_STOCK_LEVEL,
        LAST_ADJUSTMENT_TIMESTAMP,
        WAREHOUSE_LOCATION,
        UPDATED_AT
    )
    VALUES (
        source.PRODUCT_ID,
        source.PRODUCT_NAME,
        source.PRODUCT_CATEGORY,
        source.NEW_STOCK_LEVEL,
        source.LAST_ADJUSTMENT_TIMESTAMP,
        source.WAREHOUSE_LOCATION,
        source.UPDATED_AT
    );

-- ============================================
-- 4Ô∏è‚É£ ACTIVATION DES TASKS (DAG)
-- ============================================
-- Les tasks s'ex√©cutent dans l'ordre suivant :
-- 1. TASK_RAW_TO_STAGING_ORDERS (toutes les 1 min)
--    ‚îî‚îÄ‚îÄ 2. TASK_STAGING_TO_PROD_ORDERS (apr√®s task 1)
-- 3. TASK_RAW_TO_STAGING_INVENTORY (toutes les 1 min)
--    ‚îî‚îÄ‚îÄ 4. TASK_STAGING_TO_PROD_INVENTORY_HISTORY (apr√®s task 3)
--        ‚îî‚îÄ‚îÄ 5. TASK_STAGING_TO_PROD_INVENTORY_CURRENT (apr√®s task 4)

-- Activer les tasks enfants d'abord, puis les parents
ALTER TASK TASK_STAGING_TO_PROD_INVENTORY_CURRENT RESUME;
ALTER TASK TASK_STAGING_TO_PROD_INVENTORY_HISTORY RESUME;
ALTER TASK TASK_STAGING_TO_PROD_ORDERS RESUME;
ALTER TASK TASK_RAW_TO_STAGING_INVENTORY RESUME;
ALTER TASK TASK_RAW_TO_STAGING_ORDERS RESUME;

-- ============================================
-- 5Ô∏è‚É£ MONITORING ET GESTION
-- ============================================

-- V√©rifier l'√©tat des tasks
SHOW TASKS IN SCHEMA RAW_DATA;

-- Voir l'historique d'ex√©cution des tasks
SELECT
    NAME,
    STATE,
    SCHEDULED_TIME,
    COMPLETED_TIME,
    DATEDIFF('second', SCHEDULED_TIME, COMPLETED_TIME) AS DURATION_SECONDS,
    ERROR_CODE,
    ERROR_MESSAGE
FROM TABLE(INFORMATION_SCHEMA.TASK_HISTORY())
WHERE NAME IN (
    'TASK_RAW_TO_STAGING_ORDERS',
    'TASK_RAW_TO_STAGING_INVENTORY',
    'TASK_STAGING_TO_PROD_ORDERS',
    'TASK_STAGING_TO_PROD_INVENTORY_HISTORY',
    'TASK_STAGING_TO_PROD_INVENTORY_CURRENT'
)
ORDER BY SCHEDULED_TIME DESC
LIMIT 20;

-- V√©rifier si les streams ont des donn√©es en attente
SELECT 'STREAM_RAW_ORDERS' AS STREAM_NAME, SYSTEM$STREAM_HAS_DATA('STREAM_RAW_ORDERS') AS HAS_DATA
UNION ALL
SELECT 'STREAM_RAW_INVENTORY', SYSTEM$STREAM_HAS_DATA('STREAM_RAW_INVENTORY')
UNION ALL
SELECT 'STREAM_STG_ORDERS', SYSTEM$STREAM_HAS_DATA('STREAM_STG_ORDERS')
UNION ALL
SELECT 'STREAM_STG_INVENTORY', SYSTEM$STREAM_HAS_DATA('STREAM_STG_INVENTORY');

-- Voir le nombre de lignes dans chaque stream
SELECT 'STREAM_RAW_ORDERS' AS STREAM_NAME, COUNT(*) AS ROW_COUNT FROM STREAM_RAW_ORDERS
UNION ALL
SELECT 'STREAM_RAW_INVENTORY', COUNT(*) FROM STREAM_RAW_INVENTORY
UNION ALL
SELECT 'STREAM_STG_ORDERS', COUNT(*) FROM STREAM_STG_ORDERS
UNION ALL
SELECT 'STREAM_STG_INVENTORY', COUNT(*) FROM STREAM_STG_INVENTORY;

-- ============================================
-- 6Ô∏è‚É£ COMMANDES DE GESTION
-- ============================================

-- Suspendre les tasks (dans l'ordre inverse)
-- ALTER TASK TASK_RAW_TO_STAGING_ORDERS SUSPEND;
-- ALTER TASK TASK_RAW_TO_STAGING_INVENTORY SUSPEND;
-- ALTER TASK TASK_STAGING_TO_PROD_ORDERS SUSPEND;
-- ALTER TASK TASK_STAGING_TO_PROD_INVENTORY_HISTORY SUSPEND;
-- ALTER TASK TASK_STAGING_TO_PROD_INVENTORY_CURRENT SUSPEND;

-- Ex√©cuter manuellement une task (pour tester)
-- EXECUTE TASK TASK_RAW_TO_STAGING_ORDERS;

-- Supprimer les tasks (si besoin de tout recr√©er)
-- DROP TASK IF EXISTS TASK_STAGING_TO_PROD_INVENTORY_CURRENT;
-- DROP TASK IF EXISTS TASK_STAGING_TO_PROD_INVENTORY_HISTORY;
-- DROP TASK IF EXISTS TASK_STAGING_TO_PROD_ORDERS;
-- DROP TASK IF EXISTS TASK_RAW_TO_STAGING_INVENTORY;
-- DROP TASK IF EXISTS TASK_RAW_TO_STAGING_ORDERS;

-- Supprimer les streams
-- DROP STREAM IF EXISTS STREAM_STG_INVENTORY;
-- DROP STREAM IF EXISTS STREAM_STG_ORDERS;
-- DROP STREAM IF EXISTS STREAM_RAW_INVENTORY;
-- DROP STREAM IF EXISTS STREAM_RAW_ORDERS;

-- ============================================
-- 7Ô∏è‚É£ REQU√äTES ANALYTIQUES
-- ============================================

-- Top 10 des produits les plus vendus
SELECT
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    COUNT(*) AS ORDER_COUNT,
    SUM(QUANTITY) AS TOTAL_QUANTITY,
    SUM(TOTAL_AMOUNT) AS TOTAL_REVENUE
FROM PRODUCTION.ORDERS
GROUP BY PRODUCT_NAME, PRODUCT_CATEGORY
ORDER BY TOTAL_REVENUE DESC
LIMIT 10;

-- √âtat actuel de l'inventaire par cat√©gorie
SELECT
    PRODUCT_CATEGORY,
    COUNT(DISTINCT PRODUCT_ID) AS PRODUCT_COUNT,
    SUM(CURRENT_STOCK_LEVEL) AS TOTAL_STOCK,
    AVG(CURRENT_STOCK_LEVEL) AS AVG_STOCK_PER_PRODUCT
FROM PRODUCTION.INVENTORY_CURRENT
GROUP BY PRODUCT_CATEGORY
ORDER BY TOTAL_STOCK DESC;

-- Tendance des ventes par jour (derniers 30 jours)
SELECT
    ORDER_DATE,
    COUNT(*) AS ORDER_COUNT,
    SUM(TOTAL_AMOUNT) AS DAILY_REVENUE
FROM PRODUCTION.ORDERS
WHERE ORDER_DATE >= DATEADD('day', -30, CURRENT_DATE())
GROUP BY ORDER_DATE
ORDER BY ORDER_DATE DESC;

-- Alertes : Produits avec stock faible (< 50 unit√©s)
SELECT
    PRODUCT_ID,
    PRODUCT_NAME,
    PRODUCT_CATEGORY,
    CURRENT_STOCK_LEVEL,
    WAREHOUSE_LOCATION,
    LAST_ADJUSTMENT_TIMESTAMP
FROM PRODUCTION.INVENTORY_CURRENT
WHERE CURRENT_STOCK_LEVEL < 50
ORDER BY CURRENT_STOCK_LEVEL ASC;
